#pragma once

#include <common/mutators/base.qh>

// register all possible hooks here

// to use a hook, first register your mutator using REGISTER_MUTATOR
// then create your function using MUTATOR_HOOKFUNCTION

/**
 * Called when a client command is parsed
 * NOTE: hooks MUST start with if (MUTATOR_RETURNVALUE) return false;
 * NOTE: return true if you handled the command, return false to continue handling
 * NOTE: THESE HOOKS MUST NEVER EVER CALL tokenize()
 * // example:
 * MUTATOR_HOOKFUNCTION(foo, CSQC_ConsoleCommand) {
 *     if (MUTATOR_RETURNVALUE) return false; // command was already handled
 *     string cmd_name = M_ARGV(0, string);
 *     int cmd_argc = M_ARGV(1, int);
 *     if (cmd_name == "echocvar" && cmd_argc >= 2) {
 *         print(cvar_string(argv(1)), "\n");
 *         return true;
 *     }
 *     if (cmd_name == "echostring" && cmd_argc >= 2) {
 *         print(substring(cmd_string, argv_start_index(1), argv_end_index(-1) - argv_start_index(1)), "\n");
 *         return true;
 *     }
 *     return false;
 * }
 */
/*qc2rust::define::EV_CSQC_ConsoleCommand*/
#define EV_CSQC_ConsoleCommand(i,o) /*qc2rust::macro_begin::EV_CSQC_ConsoleCommand*//** command name */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_0_string)  	/** argc (also, argv() can be used) */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_1_int)  	/** whole command, use only if you really have to */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_2_string) 	/**/ /*qc2rust::macro_end::EV_CSQC_ConsoleCommand*/
MUTATOR_HOOKABLE(CSQC_ConsoleCommand, EV_CSQC_ConsoleCommand);

/* Called when the crosshair is being updated */
MUTATOR_HOOKABLE(UpdateCrosshair, EV_NO_ARGS);

/** Called when a projectile is linked with CSQC */
/*qc2rust::define::EV_Ent_Projectile*/
#define EV_Ent_Projectile(i,o) /*qc2rust::macro_begin::EV_Ent_Projectile*//** entity id */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity) 	/**/ /*qc2rust::macro_end::EV_Ent_Projectile*/
MUTATOR_HOOKABLE(Ent_Projectile, EV_Ent_Projectile);

/** Called when a projectile's properties are being modified */
/*qc2rust::define::EV_EditProjectile*/
#define EV_EditProjectile(i,o) /*qc2rust::macro_begin::EV_EditProjectile*//** entity id */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity) 	/**/ /*qc2rust::macro_end::EV_EditProjectile*/
MUTATOR_HOOKABLE(EditProjectile, EV_EditProjectile);

/* Called when projectiles are precached */
MUTATOR_HOOKABLE(PrecacheProjectiles, EV_NO_ARGS);

/** Called when updating the attached tags index */
/*qc2rust::define::EV_TagIndex_Update*/
#define EV_TagIndex_Update(i,o) /*qc2rust::macro_begin::EV_TagIndex_Update*//** entity id */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity) 	/**/ /*qc2rust::macro_end::EV_TagIndex_Update*/
MUTATOR_HOOKABLE(TagIndex_Update, EV_TagIndex_Update);

/** Called when setting the attached tags */
/*qc2rust::define::EV_TagIndex_Apply*/
#define EV_TagIndex_Apply(i,o) /*qc2rust::macro_begin::EV_TagIndex_Apply*//** entity id */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity) 	/**/ /*qc2rust::macro_end::EV_TagIndex_Apply*/
MUTATOR_HOOKABLE(TagIndex_Apply, EV_TagIndex_Apply);

/** Called when setting up skeleton bones */
/*qc2rust::define::EV_Skeleton_CheckBones*/
#define EV_Skeleton_CheckBones(i,o) /*qc2rust::macro_begin::EV_Skeleton_CheckBones*//** entity id */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity) 	/**/ /*qc2rust::macro_end::EV_Skeleton_CheckBones*/
MUTATOR_HOOKABLE(Skeleton_CheckBones, EV_Skeleton_CheckBones);

/** Called when setting up bones from the loaded model */
/*qc2rust::define::EV_Skeleton_CheckModel*/
#define EV_Skeleton_CheckModel(i,o) /*qc2rust::macro_begin::EV_Skeleton_CheckModel*//** entity id */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity) 	/**/ /*qc2rust::macro_end::EV_Skeleton_CheckModel*/
MUTATOR_HOOKABLE(Skeleton_CheckModel, EV_Skeleton_CheckModel);

/** Called when clearing the global parameters for a model */
MUTATOR_HOOKABLE(ClearModelParams, EV_NO_ARGS);

/** Called when getting the global parameters for a model */
/*qc2rust::define::EV_GetModelParams*/
#define EV_GetModelParams(i,o) /*qc2rust::macro_begin::EV_GetModelParams*//** input */   /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_0_string) 	/** command */   /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_1_string) 	/**/ /*qc2rust::macro_end::EV_GetModelParams*/
MUTATOR_HOOKABLE(GetModelParams, EV_GetModelParams);

/** Called checking if 3rd person mode should be forced on */
/*qc2rust::define::EV_WantEventchase*/
#define EV_WantEventchase(i,o) /*qc2rust::macro_begin::EV_WantEventchase*//** entity id */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity) 	/**/ /*qc2rust::macro_end::EV_WantEventchase*/
MUTATOR_HOOKABLE(WantEventchase, EV_WantEventchase);

/** allow customizing 3rd person mode effect */
/*qc2rust::define::EV_CustomizeEventchase*/
#define EV_CustomizeEventchase(i,o) /*qc2rust::macro_begin::EV_CustomizeEventchase*//** entity id */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity) 	/* current_view_origin_override */  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(vector, MUTATOR_ARGV_0_vector) 	/* view_offset_override */  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(vector, MUTATOR_ARGV_1_vector) 	/* chase_distance_override */  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_0_float) 	/**/ /*qc2rust::macro_end::EV_CustomizeEventchase*/
MUTATOR_HOOKABLE(CustomizeEventchase, EV_CustomizeEventchase);

/*qc2rust::define::EV_AnnouncerOption*/
#define EV_AnnouncerOption(i,o) /*qc2rust::macro_begin::EV_AnnouncerOption*//** announcer string */   /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_0_string) 	/** announcer string */  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(string, MUTATOR_ARGV_0_string) 	/**/ /*qc2rust::macro_end::EV_AnnouncerOption*/
MUTATOR_HOOKABLE(AnnouncerOption, EV_AnnouncerOption);

MUTATOR_HOOKABLE(Ent_Init, EV_NO_ARGS);

/*qc2rust::define::EV_HUD_Draw_overlay*/
#define EV_HUD_Draw_overlay(i,o) /*qc2rust::macro_begin::EV_HUD_Draw_overlay*//**/  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(vector, MUTATOR_ARGV_0_vector) 	/**/  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_1_float) 	/**/ /*qc2rust::macro_end::EV_HUD_Draw_overlay*/
MUTATOR_HOOKABLE(HUD_Draw_overlay, EV_HUD_Draw_overlay);

MUTATOR_HOOKABLE(HUD_Powerups_add, EV_NO_ARGS);

/** Return true to not draw any vortex beam */
/*qc2rust::define::EV_Particles_VortexBeam*/
#define EV_Particles_VortexBeam(i,o) /*qc2rust::macro_begin::EV_Particles_VortexBeam*//** beam shot origin */   /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(vector, MUTATOR_ARGV_0_vector) 	/** beam end position */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(vector, MUTATOR_ARGV_1_vector) 	/**/ /*qc2rust::macro_end::EV_Particles_VortexBeam*/
MUTATOR_HOOKABLE(Particles_VortexBeam, EV_Particles_VortexBeam);

/** Return true to not draw any impact effect */
/*qc2rust::define::EV_Weapon_ImpactEffect*/
#define EV_Weapon_ImpactEffect(i,o) /*qc2rust::macro_begin::EV_Weapon_ImpactEffect*//** weapon */ 			 /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity) 	/** damage entity */ 	 /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity) 	/**/ /*qc2rust::macro_end::EV_Weapon_ImpactEffect*/
MUTATOR_HOOKABLE(Weapon_ImpactEffect, EV_Weapon_ImpactEffect);

/* NOTE: hooks MUST start with if (MUTATOR_RETURNVALUE) return false;
*/
/*qc2rust::define::EV_HUD_Command*/
#define EV_HUD_Command(i,o) /*qc2rust::macro_begin::EV_HUD_Command*//** argc (also, argv() can be used) */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_0_int) 	/**/ /*qc2rust::macro_end::EV_HUD_Command*/
MUTATOR_HOOKABLE(HUD_Command, EV_HUD_Command);

/** Draw the grapple hook, allows changing hook texture and colour */
/*qc2rust::define::EV_DrawGrapplingHook*/
#define EV_DrawGrapplingHook(i,o) /*qc2rust::macro_begin::EV_DrawGrapplingHook*//** hook */ 			 /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity) 	/** texture */ 			 /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_1_string) 	/***/ 					 /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(string, MUTATOR_ARGV_1_string) 	/** colour */ 			 /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(vector, MUTATOR_ARGV_2_vector) 	/***/ 					 /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(vector, MUTATOR_ARGV_2_vector) 	/** team */ 			 /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_3_float) 	/**/ /*qc2rust::macro_end::EV_DrawGrapplingHook*/
MUTATOR_HOOKABLE(DrawGrapplingHook, EV_DrawGrapplingHook);

/** Called when an entity is updated (either by SVQC networking or PVS) */
/*qc2rust::define::EV_Ent_Update*/
#define EV_Ent_Update(i,o) /*qc2rust::macro_begin::EV_Ent_Update*//** entity id */ 		 /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity) 	/** is new to client */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(bool, MUTATOR_ARGV_1_bool) 	/**/ /*qc2rust::macro_end::EV_Ent_Update*/
MUTATOR_HOOKABLE(Ent_Update, EV_Ent_Update);

/** Return true to not draw crosshair */
MUTATOR_HOOKABLE(DrawCrosshair, EV_NO_ARGS);

/** Return true to not draw scoreboard */
MUTATOR_HOOKABLE(DrawScoreboard, EV_NO_ARGS);

/** Called when drawing info messages, allows adding new info messages */
/*qc2rust::define::EV_DrawInfoMessages*/
#define EV_DrawInfoMessages(i,o) /*qc2rust::macro_begin::EV_DrawInfoMessages*//** pos */ 			     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(vector, MUTATOR_ARGV_0_vector) 	/** mySize */ 			 /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(vector, MUTATOR_ARGV_1_vector) 	/**/ /*qc2rust::macro_end::EV_DrawInfoMessages*/
MUTATOR_HOOKABLE(DrawInfoMessages, EV_DrawInfoMessages);

/** Called when drawing info messages, allows adding new info messages */
/*qc2rust::define::EV_HUD_WriteCvars*/
#define EV_HUD_WriteCvars(i,o) /*qc2rust::macro_begin::EV_HUD_WriteCvars*//** file */ 			 /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_0_float) 	/**/ /*qc2rust::macro_end::EV_HUD_WriteCvars*/
MUTATOR_HOOKABLE(HUD_WriteCvars, EV_HUD_WriteCvars);

/** Called when the view model is being animated (setorigin is called after the hook, so you only need to modify origin here if desired) */
/*qc2rust::define::EV_DrawViewModel*/
#define EV_DrawViewModel(i,o) /*qc2rust::macro_begin::EV_DrawViewModel*//** entity id */ 		 /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity) 	/**/ /*qc2rust::macro_end::EV_DrawViewModel*/
MUTATOR_HOOKABLE(DrawViewModel, EV_DrawViewModel);

/** Called when updating the view's liquid contents, return true to disable the standard checks and apply your own */
MUTATOR_HOOKABLE(HUD_Contents, EV_NO_ARGS);

/** Return true to disable player model/color forcing */
/*qc2rust::define::EV_ForcePlayermodels_Skip*/
#define EV_ForcePlayermodels_Skip(i,o) /*qc2rust::macro_begin::EV_ForcePlayermodels_Skip*//** entity id */ 		 /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity) 	/** is local */ 		 /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(bool, MUTATOR_ARGV_1_bool) 	/**/ /*qc2rust::macro_end::EV_ForcePlayermodels_Skip*/
MUTATOR_HOOKABLE(ForcePlayermodels_Skip, EV_ForcePlayermodels_Skip);

/** Called when damage info is received on the client, useful for playing explosion effects */
/*qc2rust::define::EV_DamageInfo*/
#define EV_DamageInfo(i,o) /*qc2rust::macro_begin::EV_DamageInfo*//** entity id */ 		 /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity) 	/** death type */ 		 /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_1_int) 	/** hit origin */ 		 /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(vector, MUTATOR_ARGV_2_vector) 	/**/ /*qc2rust::macro_end::EV_DamageInfo*/
MUTATOR_HOOKABLE(DamageInfo, EV_DamageInfo);
