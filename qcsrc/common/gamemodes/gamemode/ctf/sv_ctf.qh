#pragma once

#include "ctf.qh"

void ctf_Initialize();

REGISTER_MUTATOR(ctf, false)
{
    MUTATOR_STATIC();
    MUTATOR_ONADD
    {
        GameRules_teams(true);
        GameRules_limit_score(autocvar_capturelimit_override);
        GameRules_limit_lead(autocvar_captureleadlimit_override);

        ctf_Initialize();
    }
    return 0;
}

// used in cheats.qc
void ctf_RespawnFlag(entity flag);

// score rule declarations
const int ST_CTF_CAPS = 1;

CLASS(Flag, Pickup)
    ATTRIB(Flag, m_mins, vector, (PL_MIN_CONST + '0 0 -13') * 1.4); // scaling be damned
    ATTRIB(Flag, m_maxs, vector, (PL_MAX_CONST + '0 0 -13') * 1.4);
ENDCLASS(Flag)
Flag CTF_FLAG; STATIC_INIT(Flag) { CTF_FLAG = NEW(Flag); }
void ctf_FlagTouch(entity this, entity toucher) { ITEM_HANDLE(Pickup, CTF_FLAG, this, toucher); }

// flag constants // for most of these, there is just one question to be asked: WHYYYYY?

const float FLAG_SCALE = 0.6;

const float FLAG_THINKRATE = 0.2;
const float FLAG_TOUCHRATE = 0.5;
const float WPFE_THINKRATE = 0.5;

const vector FLAG_DROP_OFFSET = ('0 0 32');
const vector FLAG_CARRY_OFFSET = ('-16 0 8');
/*qc2rust::define::FLAG_SPAWN_OFFSET*/
#define FLAG_SPAWN_OFFSET /*qc2rust::macro_begin::FLAG_SPAWN_OFFSET*/('0 0 1' * (PL_MAX_CONST.z - 13)) /*qc2rust::macro_end::FLAG_SPAWN_OFFSET*/
const vector FLAG_WAYPOINT_OFFSET = ('0 0 64');
const int FLAG_FLOAT_OFFSET_Z = 32;
const int FLAG_PASS_ARC_OFFSET_Z = -10;

const vector VEHICLE_FLAG_OFFSET = ('0 0 96');
const float VEHICLE_FLAG_SCALE = 1.0;

// waypoint colors
/*qc2rust::define::WPCOLOR_ENEMYFC*/
#define WPCOLOR_ENEMYFC(t) /*qc2rust::macro_begin::WPCOLOR_ENEMYFC*/(( /*qc2rust::param_begin::t*/t /*qc2rust::param_end::t*/) ? colormapPaletteColor( /*qc2rust::param_begin::t*/t /*qc2rust::param_end::t*/ - 1, false) * 0.75 : '1 1 1') /*qc2rust::macro_end::WPCOLOR_ENEMYFC*/
/*qc2rust::define::WPCOLOR_FLAGCARRIER*/
#define WPCOLOR_FLAGCARRIER(t) /*qc2rust::macro_begin::WPCOLOR_FLAGCARRIER*/(( /*qc2rust::param_begin::t*/t /*qc2rust::param_end::t*/) ? colormapPaletteColor( /*qc2rust::param_begin::t*/t /*qc2rust::param_end::t*/ - 1, false) * 0.75 : '1 1 1') /*qc2rust::macro_end::WPCOLOR_FLAGCARRIER*/
//#define WPCOLOR_FLAGCARRIER(t) (WP_FlagCarrier.m_color)
/*qc2rust::define::WPCOLOR_DROPPEDFLAG*/
#define WPCOLOR_DROPPEDFLAG(t) /*qc2rust::macro_begin::WPCOLOR_DROPPEDFLAG*/(( /*qc2rust::param_begin::t*/t /*qc2rust::param_end::t*/) ? ('0.25 0.25 0.25' + colormapPaletteColor( /*qc2rust::param_begin::t*/t /*qc2rust::param_end::t*/ - 1, false)) * 0.5 : '1 1 1') /*qc2rust::macro_end::WPCOLOR_DROPPEDFLAG*/

// sounds
/*qc2rust::define::snd_flag_taken*/
#define snd_flag_taken /*qc2rust::macro_begin::snd_flag_taken*/noise /*qc2rust::macro_end::snd_flag_taken*/
/*qc2rust::define::snd_flag_returned*/
#define snd_flag_returned /*qc2rust::macro_begin::snd_flag_returned*/noise1 /*qc2rust::macro_end::snd_flag_returned*/
/*qc2rust::define::snd_flag_capture*/
#define snd_flag_capture /*qc2rust::macro_begin::snd_flag_capture*/noise2 /*qc2rust::macro_end::snd_flag_capture*/
/*qc2rust::define::snd_flag_respawn*/
#define snd_flag_respawn /*qc2rust::macro_begin::snd_flag_respawn*/noise3 /*qc2rust::macro_end::snd_flag_respawn*/
.string snd_flag_dropped;
.string snd_flag_touch;
.string snd_flag_pass;

// score fields
.float score_assist;
.float score_capture;
.float score_drop; // note: negated
.float score_pickup;
.float score_return;
.float score_team_capture; // shouldn't be too high

// effects
.string toucheffect;
.string passeffect;
.string capeffect;

// list of flags on the map
entity ctf_worldflaglist;
.entity ctf_worldflagnext;
.entity ctf_staleflagnext;

// waypoint sprites
.entity wps_helpme;
.entity wps_flagbase;
.entity wps_flagcarrier;
.entity wps_flagdropped;
.entity wps_flagreturn;
.entity wps_enemyflagcarrier;
.float wps_helpme_time;
bool wpforenemy_announced;
float wpforenemy_nextthink;

// statuses
const int FLAG_BASE = 1;
const int FLAG_DROPPED = 2;
const int FLAG_CARRY = 3;
const int FLAG_PASSING = 4;

const int DROP_NORMAL = 1;
const int DROP_THROW = 2;
const int DROP_PASS = 3;
const int DROP_RESET = 4;

const int PICKUP_BASE = 1;
const int PICKUP_DROPPED = 2;

const int CAPTURE_NORMAL = 1;
const int CAPTURE_DROPPED = 2;

const int RETURN_TIMEOUT = 1;
const int RETURN_DROPPED = 2;
const int RETURN_DAMAGE = 3;
const int RETURN_SPEEDRUN = 4;
const int RETURN_NEEDKILL = 5;

bool ctf_Stalemate_Customize(entity this, entity client);

void ctf_Handle_Throw(entity player, entity receiver, float droptype);

// flag properties
/*qc2rust::define::ctf_spawnorigin*/
#define ctf_spawnorigin /*qc2rust::macro_begin::ctf_spawnorigin*/dropped_origin /*qc2rust::macro_end::ctf_spawnorigin*/
bool ctf_stalemate; // indicates that a stalemate is active
float ctf_captimerecord; // record time for capturing the flag
.float ctf_pickuptime;
.float ctf_droptime;
.int ctf_status; // status of the flag (FLAG_BASE, FLAG_DROPPED, FLAG_CARRY declared globally)
.entity ctf_dropper; // don't allow spam of dropping the flag
.int max_flag_health;
.float next_take_time;
.bool ctf_flagdamaged_byworld;
int ctf_teams;
.entity enemy; // when flag is back in the base, it remembers last player who carried/touched the flag, useful to bots

// passing/throwing properties
.float pass_distance;
.entity pass_sender;
.entity pass_target;
.float throw_antispam;
.float throw_prevtime;
.int throw_count;

// CaptureShield: If the player is too bad to be allowed to capture, shield them from taking the flag.
.bool ctf_captureshielded; // set to 1 if the player is too bad to be allowed to capture
float ctf_captureshield_min_negscore; // punish at -20 points
float ctf_captureshield_max_ratio; // punish at most 30% of each team
float ctf_captureshield_force; // push force of the shield

// 1 flag ctf
bool ctf_oneflag; // indicates whether or not a neutral flag has been found

// bot player logic
const int HAVOCBOT_CTF_ROLE_NONE = 0;
const int HAVOCBOT_CTF_ROLE_DEFENSE = 2;
const int HAVOCBOT_CTF_ROLE_MIDDLE = 4;
const int HAVOCBOT_CTF_ROLE_OFFENSE = 8;
const int HAVOCBOT_CTF_ROLE_CARRIER = 16;
const int HAVOCBOT_CTF_ROLE_RETRIEVER = 32;
const int HAVOCBOT_CTF_ROLE_ESCORT = 64;

.bool havocbot_cantfindflag;

void havocbot_role_ctf_setrole(entity bot, int role);

// team checking
/*qc2rust::define::CTF_SAMETEAM*/
#define CTF_SAMETEAM(a,b) /*qc2rust::macro_begin::CTF_SAMETEAM*/((autocvar_g_ctf_reverse || (ctf_oneflag && autocvar_g_ctf_oneflag_reverse)) ? DIFF_TEAM( /*qc2rust::param_begin::a*/a /*qc2rust::param_end::a*/, /*qc2rust::param_begin::b*/b /*qc2rust::param_end::b*/) : SAME_TEAM( /*qc2rust::param_begin::a*/a /*qc2rust::param_end::a*/, /*qc2rust::param_begin::b*/b /*qc2rust::param_end::b*/)) /*qc2rust::macro_end::CTF_SAMETEAM*/
/*qc2rust::define::CTF_DIFFTEAM*/
#define CTF_DIFFTEAM(a,b) /*qc2rust::macro_begin::CTF_DIFFTEAM*/((autocvar_g_ctf_reverse || (ctf_oneflag && autocvar_g_ctf_oneflag_reverse)) ? SAME_TEAM( /*qc2rust::param_begin::a*/a /*qc2rust::param_end::a*/, /*qc2rust::param_begin::b*/b /*qc2rust::param_end::b*/) : DIFF_TEAM( /*qc2rust::param_begin::a*/a /*qc2rust::param_end::a*/, /*qc2rust::param_begin::b*/b /*qc2rust::param_end::b*/)) /*qc2rust::macro_end::CTF_DIFFTEAM*/
