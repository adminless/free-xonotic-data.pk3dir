#pragma once

/**
 * Purpose: common player state, usable on client and server
 * Client: singleton representing the viewed player
 * Server: instance per client, clients decoupled from players
 */
CLASS(PlayerState, Object)
	ATTRIB(PlayerState, m_client, entity);
	CONSTRUCTOR(PlayerState, entity client)
	{
		CONSTRUCT(PlayerState);
		this.m_client = client;
	}
ENDCLASS(PlayerState)

.PlayerState _ps;
/*qc2rust::define::PS*/
#define PS(this) /*qc2rust::macro_begin::PS*/(( /*qc2rust::param_begin::this*/this /*qc2rust::param_end::this*/)._ps) /*qc2rust::macro_end::PS*/

// TODO: renew on death
void PlayerState_attach(entity this);
void PlayerState_detach(entity this);

/**
 * Purpose: common client state, usable on client and server
 * Client: singleton representing the viewed player
 * Server: instance per client
 */
CLASS(ClientState, Object)
	ATTRIB(ClientState, m_client, entity);
	CONSTRUCTOR(ClientState, entity client)
	{
		CONSTRUCT(ClientState);
		this.m_client = client;
	}
	METHOD(PlayerState, ps_push, void(PlayerState this, entity cl))
	{
		TC(PlayerState, this);
	}
ENDCLASS(ClientState)

.ClientState _cs;

#if NDEBUG
/*qc2rust::define::CS*/
#define CS(this) /*qc2rust::macro_begin::CS*/( /*qc2rust::param_begin::this*/this /*qc2rust::param_end::this*/._cs) /*qc2rust::macro_end::CS*/
#else
	ClientState CS(Client this) { TC(Client, this); assert(this._cs); return this._cs; }
#endif

void ClientState_attach(entity this);
void ClientState_detach(entity this);
