#pragma once

#ifdef SVQC
	#include <server/autocvars.qh>
#endif

#ifdef SVQC
float tracebox_inverted (vector v1, vector mi, vector ma, vector v2, float nomonsters, entity forent, float stopatentity, entity ignorestopatentity); // returns the number of traces done, for benchmarking

void traceline_inverted (vector v1, vector v2, float nomonsters, entity forent, float stopatentity, entity ignorestopatentity);
#endif

#ifdef GAMEQC
/*
==================
findbetterlocation

Returns a point at least 12 units away from walls
(useful for explosion animations, although the blast is performed where it really happened)
Ripped from DPMod
==================
*/
vector findbetterlocation (vector org, float mindist);

vector real_origin(entity ent);
#endif

#ifdef SVQC
// temporary array used to dump weapon and turret settings
const int MAX_CONFIG_SETTINGS = 256;
string config_queue[MAX_CONFIG_SETTINGS];
#endif

.string netname;
.string message;

IntrusiveList g_saved_cvars;
STATIC_INIT(g_saved_cvars) { g_saved_cvars = IL_NEW(); }

// this returns a tempstring containing a copy of s with additional \n newlines added, it also replaces \n in the text with a real newline
// NOTE: s IS allowed to be a tempstring
string wordwrap(string s, float l);
#ifdef SVQC
void wordwrap_sprint(entity to, string s, float l);
#endif
void wordwrap_cb(string s, float l, void(string) callback);

#ifndef SVQC
string draw_currentSkin;
string draw_UseSkinFor(string pic);
#endif

// iterative depth-first search, with fields that go "up", "down left" and "right" in a tree
// for each element, funcPre is called first, then funcPre and funcPost for all its children, and funcPost last
void depthfirst(entity start, .entity up, .entity downleft, .entity right, void(entity, entity) funcPre, void(entity, entity) funcPost, entity pass);

/*qc2rust::define::TIME_TO_NTHS*/
#define TIME_TO_NTHS(t,n) /*qc2rust::macro_begin::TIME_TO_NTHS*/floor(( /*qc2rust::param_begin::t*/t /*qc2rust::param_end::t*/) * ( /*qc2rust::param_begin::n*/n /*qc2rust::param_end::n*/) + 0.5) /*qc2rust::macro_end::TIME_TO_NTHS*/

const int TIME_DECIMALS = 2;
const float TIME_FACTOR = 100;
/*qc2rust::define::TIME_ENCODED_TOSTRING*/
#define TIME_ENCODED_TOSTRING(n) /*qc2rust::macro_begin::TIME_ENCODED_TOSTRING*/mmssss( /*qc2rust::param_begin::n*/n /*qc2rust::param_end::n*/) /*qc2rust::macro_end::TIME_ENCODED_TOSTRING*/
/*qc2rust::define::RACE_RECORD*/
#define RACE_RECORD /*qc2rust::macro_begin::RACE_RECORD*/"/race100record/" /*qc2rust::macro_end::RACE_RECORD*/
/*qc2rust::define::CTS_RECORD*/
#define CTS_RECORD /*qc2rust::macro_begin::CTS_RECORD*/"/cts100record/" /*qc2rust::macro_end::CTS_RECORD*/
/*qc2rust::define::CTF_RECORD*/
#define CTF_RECORD /*qc2rust::macro_begin::CTF_RECORD*/"/ctf100record/" /*qc2rust::macro_end::CTF_RECORD*/
/*qc2rust::define::TIME_ENCODE*/
#define TIME_ENCODE(t) /*qc2rust::macro_begin::TIME_ENCODE*/TIME_TO_NTHS( /*qc2rust::param_begin::t*/t /*qc2rust::param_end::t*/, TIME_FACTOR) /*qc2rust::macro_end::TIME_ENCODE*/
/*qc2rust::define::TIME_DECODE*/
#define TIME_DECODE(n) /*qc2rust::macro_begin::TIME_DECODE*/(( /*qc2rust::param_begin::n*/n /*qc2rust::param_end::n*/) / TIME_FACTOR) /*qc2rust::macro_end::TIME_DECODE*/

#ifdef GAMEQC
string ScoreString(float vflags, float value);
#endif

vector decompressShortVector(float data);
float compressShortVector(vector vec);

#ifdef GAMEQC
float CheckWireframeBox(entity forent, vector v0, vector dvx, vector dvy, vector dvz);
#endif

string fixPriorityList(string pl, float from, float to, float subtract, float complete);
string mapPriorityList(string order, string(string) mapfunc);
string swapInPriorityList(string order, float i, float j);

float cvar_settemp(string pKey, string pValue);
float cvar_settemp_restore();

#ifdef GAMEQC
// modes: 0 = trust q3map2 (_mini images)
//        1 = trust tracebox (_radar images)
// in both modes, mapinfo's "size" overrides

string mi_shortname;
vector mi_min;
vector mi_max;
void get_mi_min_max(float mode);

vector mi_picmin; // adjusted mins that map to the picture (square)
vector mi_picmax; // adjusted maxs that map to the picture (square)
vector mi_pictexcoord0; // texcoords of the image corners (after transforming, these are 2D coords too)
vector mi_pictexcoord1; // texcoords of the image corners (after transforming, these are 2D coords too)
vector mi_pictexcoord2; // texcoords of the image corners (after transforming, these are 2D coords too)
vector mi_pictexcoord3; // texcoords of the image corners (after transforming, these are 2D coords too)
void get_mi_min_max_texcoords(float mode);
#endif

USING(textLengthUpToWidth_widthFunction_t, float(string s, vector size));
USING(textLengthUpToLength_lenFunction_t, float(string s));
float textLengthUpToWidth(string theText, float maxWidth, vector size, textLengthUpToWidth_widthFunction_t tw);
string textShortenToWidth(string theText, float maxWidth, vector size, textLengthUpToWidth_widthFunction_t tw);
float textLengthUpToLength(string theText, float maxWidth, textLengthUpToLength_lenFunction_t tw);
string textShortenToLength(string theText, float maxWidth, textLengthUpToLength_lenFunction_t tw);

string getWrappedLine_remaining;
string getWrappedLine(float w, vector size, textLengthUpToWidth_widthFunction_t tw);
string getWrappedLineLen(float w, textLengthUpToLength_lenFunction_t tw);

float isGametypeInFilter(entity gt, float tp, float ts, string pattern);

vector solve_shotdirection(vector myorg, vector myvel, vector eorg, vector evel, float spd, float newton_style);
vector get_shotvelocity(vector myvel, vector mydir, float spd, float newton_style, float mi, float ma);

float compressShotOrigin(vector v);
vector decompressShotOrigin(float f);

#ifdef SVQC
string rankings_reply, ladder_reply, lsmaps_reply, maplist_reply, monsterlist_reply; // cached replies
string records_reply[10];
#endif

#ifdef GAMEQC
vector healtharmor_maxdamage(float h, float a, float armorblock, int deathtype); // returns vector: maxdamage, armorideal, 1 if fully armored
vector healtharmor_applydamage(float a, float armorblock, int deathtype, float damage); // returns vector: take, save, 0
#endif

string getcurrentmod();

float matchacl(string acl, string str); // matches str against ACL acl (with entries +foo*, +foo, +*foo, +*foo*, and same with - for forbidding)

void write_String_To_File(int fh, string str, bool alsoprint);

string get_model_datafilename(string mod, float skn, string fil); // skin -1 will return wildcard, mod string_null will also put wildcard there
string get_model_parameters_modelname;
float get_model_parameters_modelskin;
string get_model_parameters_name;
float get_model_parameters_species;
string get_model_parameters_sex;
float get_model_parameters_weight;
float get_model_parameters_age;
bool get_model_parameters_hidden;
string get_model_parameters_description;
string get_model_parameters_bone_upperbody;
string get_model_parameters_bone_weapon;
const int MAX_AIM_BONES = 4;
string get_model_parameters_bone_aim[MAX_AIM_BONES];
float get_model_parameters_bone_aimweight[MAX_AIM_BONES];
float get_model_parameters_fixbone;
string get_model_parameters_desc;
float get_model_parameters(string mod, float skn); // call with string_null to clear; skin -1 means mod is the filename of the txt file and is to be split

// x-encoding (encoding as zero length invisible string)
// encodes approx. 14 bits into 5 bytes of color code string
const float XENCODE_MAX = 21295; // 2*22*22*22-1
const float XENCODE_LEN = 5;
string xencode(float f);
float xdecode(string s);

#ifdef GAMEQC
string strtolower(string s);
#endif

// generic shutdown handler
void Shutdown();

#ifdef GAMEQC
.float skeleton_bones;
void Skeleton_SetBones(entity e);
// loops through the tags of model v using counter tagnum
/*qc2rust::define::FOR_EACH_TAG*/
#define FOR_EACH_TAG(v) /*qc2rust::macro_begin::FOR_EACH_TAG*/float tagnum; Skeleton_SetBones( /*qc2rust::param_begin::v*/v /*qc2rust::param_end::v*/); for(tagnum = 0; tagnum <  /*qc2rust::param_begin::v*/v /*qc2rust::param_end::v*/.skeleton_bones; tagnum++, gettaginfo( /*qc2rust::param_begin::v*/v /*qc2rust::param_end::v*/, tagnum)) /*qc2rust::macro_end::FOR_EACH_TAG*/
#endif

// execute-stuff-next-frame subsystem
void execute_next_frame();
void queue_to_execute_next_frame(string s);

USING(findNextEntityNearFunction_t, entity(entity cur, entity near, entity pass));
USING(isConnectedFunction_t, float(entity a, entity b, entity pass));
void FindConnectedComponent(entity e, .entity fld, findNextEntityNearFunction_t nxt, isConnectedFunction_t iscon, entity pass);

// expand multiple arguments into one argument by stripping parenthesis
/*qc2rust::define::XPD*/
#define XPD(...) /*qc2rust::macro_begin::XPD*/ /*qc2rust::param_begin::__VA_ARGS__*/__VA_ARGS__ /*qc2rust::param_end::__VA_ARGS__*/ /*qc2rust::macro_end::XPD*/

// Some common varargs functions. Lowercase as they match C.
/*qc2rust::define::fprintf*/
#define fprintf(file,...) /*qc2rust::macro_begin::fprintf*/fputs( /*qc2rust::param_begin::file*/file /*qc2rust::param_end::file*/, sprintf( /*qc2rust::param_begin::__VA_ARGS__*/__VA_ARGS__ /*qc2rust::param_end::__VA_ARGS__*/)) /*qc2rust::macro_end::fprintf*/
/*qc2rust::define::bprintf*/
#define bprintf(...) /*qc2rust::macro_begin::bprintf*/bprint(sprintf( /*qc2rust::param_begin::__VA_ARGS__*/__VA_ARGS__ /*qc2rust::param_end::__VA_ARGS__*/)) /*qc2rust::macro_end::bprintf*/

#ifdef GAMEQC
	#ifdef CSQC
/*qc2rust::define::GENTLE*/
#define GENTLE /*qc2rust::macro_begin::GENTLE*/(autocvar_cl_gentle || autocvar_cl_gentle_messages) /*qc2rust::macro_end::GENTLE*/
	#else
/*qc2rust::define::GENTLE*/
#define GENTLE /*qc2rust::macro_begin::GENTLE*/autocvar_sv_gentle /*qc2rust::macro_end::GENTLE*/
	#endif
/*qc2rust::define::normal_or_gentle*/
#define normal_or_gentle(normal,gentle) /*qc2rust::macro_begin::normal_or_gentle*/(GENTLE ? (( /*qc2rust::param_begin::gentle*/gentle /*qc2rust::param_end::gentle*/ != "") ?  /*qc2rust::param_begin::gentle*/gentle /*qc2rust::param_end::gentle*/ :  /*qc2rust::param_begin::normal*/normal /*qc2rust::param_end::normal*/) :  /*qc2rust::param_begin::normal*/normal /*qc2rust::param_end::normal*/) /*qc2rust::macro_end::normal_or_gentle*/
#endif

#ifdef GAMEQC
vector animfixfps(entity e, vector a, vector b);
#endif

#ifdef GAMEQC
const int CNT_NORMAL = 1;
const int CNT_GAMESTART = 2;
const int CNT_IDLE = 3;
const int CNT_KILL = 4;
const int CNT_RESPAWN = 5;
const int CNT_ROUNDSTART = 6;
entity Announcer_PickNumber(int type, int num);
#endif

#ifdef GAMEQC
int Mod_Q1BSP_SuperContentsFromNativeContents(int nativecontents);
int Mod_Q1BSP_NativeContentsFromSuperContents(int supercontents);
#endif

/*qc2rust::define::APPEND_TO_STRING*/
#define APPEND_TO_STRING(list,sep,add) /*qc2rust::macro_begin::APPEND_TO_STRING*/(( /*qc2rust::param_begin::list*/list /*qc2rust::param_end::list*/) = ((( /*qc2rust::param_begin::list*/list /*qc2rust::param_end::list*/) != "") ? strcat( /*qc2rust::param_begin::list*/list /*qc2rust::param_end::list*/,  /*qc2rust::param_begin::sep*/sep /*qc2rust::param_end::sep*/,  /*qc2rust::param_begin::add*/add /*qc2rust::param_end::add*/) : ( /*qc2rust::param_begin::add*/add /*qc2rust::param_end::add*/))) /*qc2rust::macro_end::APPEND_TO_STRING*/

// Returns the correct difference between two always increasing numbers
/*qc2rust::define::COMPARE_INCREASING*/
#define COMPARE_INCREASING(to,from) /*qc2rust::macro_begin::COMPARE_INCREASING*/( /*qc2rust::param_begin::to*/to /*qc2rust::param_end::to*/ <  /*qc2rust::param_begin::from*/from /*qc2rust::param_end::from*/ ?  /*qc2rust::param_begin::from*/from /*qc2rust::param_end::from*/ +  /*qc2rust::param_begin::to*/to /*qc2rust::param_end::to*/ + 2 :  /*qc2rust::param_begin::to*/to /*qc2rust::param_end::to*/ -  /*qc2rust::param_begin::from*/from /*qc2rust::param_end::from*/) /*qc2rust::macro_end::COMPARE_INCREASING*/
