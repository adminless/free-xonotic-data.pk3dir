#include "test.qh"

/**
 * handle string spacing as markdown:
 *   - two spaces escape a linebreak (otherwise text wraps)
 *   - two linebreaks become a paragraph (remain unchanged)
 */
ERASEABLE
string markdown(string s)
{
	string buf = "";
	int lines = 0;
	int spaces = 0;
	FOREACH_CHAR(s, true, {
		switch (it) {
			default:
				for (; spaces > 0; --spaces) {
					buf = strcat(buf, " ");
				}
				buf = strcat(buf, chr2str(it));
				break;
			case ' ':
				spaces += 1;
				break;
			case '\n':
				lines += 1;
				if (lines > 1) {
					lines = 0;
					spaces = 0;
					buf = strcat(buf, "\n\n");
					break;
				}
				if (spaces < 2) {
					spaces = 1;
				} else {
					spaces = 0;
					buf = strcat(buf, "\n");
				}
				break;
		}
	});
	return buf;
}

TEST(Markdown, LineWrap)
{
/*qc2rust::define::X*/
#define X(expect,in) /*qc2rust::macro_begin::X*/MACRO_BEGIN 		string out = markdown( /*qc2rust::param_begin::in*/in /*qc2rust::param_end::in*/); 		EXPECT_TRUE( /*qc2rust::param_begin::expect*/expect /*qc2rust::param_end::expect*/ == out); 		LOG_INFO( /*qc2rust::param_begin::expect*/expect /*qc2rust::param_end::expect*/); 		LOG_INFO(out); 	MACRO_END /*qc2rust::macro_end::X*/

	// identity
	X("lorem ipsum", "lorem ipsum");
	// trim trailing space
	X("lorem ipsum", "lorem ipsum ");
	// allow manual input wrapping
	X("lorem ipsum", "lorem\nipsum");
	// line break
	X("lorem\nipsum", "lorem  \nipsum");
	// paragraph
	X("lorem\n\nipsum", "lorem\n\nipsum");
	SUCCEED();
	#undef X
}
