#pragma once

#include "oo.qh"

#if 1
/*qc2rust::define::_R_MAP*/
#define _R_MAP(r,max) /*qc2rust::macro_begin::_R_MAP*/ArrayList  /*qc2rust::param_begin::r*/r /*qc2rust::param_end::r*/; STATIC_INIT( /*qc2rust::param_begin::r*/r /*qc2rust::param_end::r*/) { AL_NEW( /*qc2rust::param_begin::r*/r /*qc2rust::param_end::r*/,  /*qc2rust::param_begin::max*/max /*qc2rust::param_end::max*/, NULL, e); } /*qc2rust::macro_end::_R_MAP*/
/*qc2rust::define::_R_GET*/
#define _R_GET(r,i) /*qc2rust::macro_begin::_R_GET*/AL_gete( /*qc2rust::param_begin::r*/r /*qc2rust::param_end::r*/,  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/) /*qc2rust::macro_end::_R_GET*/
/*qc2rust::define::_R_SET*/
#define _R_SET(r,i,e) /*qc2rust::macro_begin::_R_SET*/AL_sete( /*qc2rust::param_begin::r*/r /*qc2rust::param_end::r*/,  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/,  /*qc2rust::param_begin::e*/e /*qc2rust::param_end::e*/) /*qc2rust::macro_end::_R_SET*/
/*qc2rust::define::_R_DEL*/
#define _R_DEL(r) /*qc2rust::macro_begin::_R_DEL*/AL_DELETE( /*qc2rust::param_begin::r*/r /*qc2rust::param_end::r*/) /*qc2rust::macro_end::_R_DEL*/
#else
/*qc2rust::define::_R_MAP*/
#define _R_MAP(r,max) /*qc2rust::macro_begin::_R_MAP*/entity  /*qc2rust::param_begin::r*/r /*qc2rust::param_end::r*/[ /*qc2rust::param_begin::max*/max /*qc2rust::param_end::max*/] /*qc2rust::macro_end::_R_MAP*/
/*qc2rust::define::_R_GET*/
#define _R_GET(r,i) /*qc2rust::macro_begin::_R_GET*/ /*qc2rust::param_begin::r*/r /*qc2rust::param_end::r*/[ /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/] /*qc2rust::macro_end::_R_GET*/
/*qc2rust::define::_R_SET*/
#define _R_SET(r,i,e) /*qc2rust::macro_begin::_R_SET*/ /*qc2rust::param_begin::r*/r /*qc2rust::param_end::r*/[ /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/] =  /*qc2rust::param_begin::e*/e /*qc2rust::param_end::e*/ /*qc2rust::macro_end::_R_SET*/
/*qc2rust::define::_R_DEL*/
#define _R_DEL(r) /*qc2rust::macro_begin::_R_DEL*/ /*qc2rust::macro_end::_R_DEL*/
#endif

/**
 * Declare a new registry.
 *
 * Don't forget to call `REGISTER_REGISTRY`:
 *     REGISTER_REGISTRY(Foos)
 */
#define REGISTRY(id, max) 	void Register##id(); 	ACCUMULATE void REGISTRY_DEPENDS_(id) {} 	REGISTRY_BEGIN(id) {} 	REGISTRY_END(id) {} 	void _Register##id() {} 	int id##_state = 0; 	void Register##id() { if (id##_state) return; id##_state = 1; REGISTRY_DEPENDS_(id); REGISTRY_BEGIN_(id); _Register##id(); id##_state = 2; REGISTRY_END_(id); } 	const int id##_MAX = max; 	int id##_COUNT; 	noref entity id##_first, id##_last; 	_R_MAP(_##id, id##_MAX); 	SHUTDOWN(id) { _R_DEL(_##id); } 	entity _##id##_from(int i, entity null) { if (i >= 0 && i < id##_COUNT) { entity e = _R_GET(_##id, i); if (e) return e; } return null; }

/** Add registry dependencies to a registry */
#define REGISTRY_DEPENDS(id, dep) void Register##dep(); void REGISTRY_DEPENDS_(id) { Register##dep(); }
#define REGISTRY_DEPENDS_(id) Register##id##_Depends()

/** Called before initializing a registry. */
#define REGISTRY_BEGIN(id) ACCUMULATE void REGISTRY_BEGIN_(id) { noref void() f = Register##id; } void REGISTRY_BEGIN_(id)
#define REGISTRY_BEGIN_(id) Register##id##_First()

/** Called after initializing a registry. */
#define REGISTRY_END(id) ACCUMULATE void REGISTRY_END_(id) { noref void() f = Register##id; } void REGISTRY_END_(id)
#define REGISTRY_END_(id) Register##id##_Done()

REGISTRY(Registries, BITS(8))

/** registered item identifier */
.string registered_id;

void _regCheck(int i, int _max)
{
	// this is inside a function to avoid expanding it on compilation everytime
	// (this very long line would be repeated literally thousands times!)
	if (i >= _max)
		LOG_FATALF("Registry capacity exceeded (%d)", _max);
}

/**
 * Register a new entity with a registry.
 * Must be followed by a semicolon or a function body with a `this` parameter.
 * Wrapper macros may perform actions after user initialization like so:
 *     #define REGISTER_FOO(id)  *         REGISTER(Foos, FOO, id, m_id, NEW(Foo)) {  *             print("Registering foo #", this.m_id + 1, "\n");  *         }  *         REGISTER_INIT(FOO, id)
 *
 *
 * @param registry  The registry to add each entity to.
 * @param ns        Short for namespace, prefix for each global (ns##_##id)
 * @param id        The identifier of the current entity being registered
 * @param fld       The field to store the locally unique unique entity id
 * @param inst      An expression to create a new instance, invoked for every registration
 */
/*qc2rust::define::REGISTER*/
#define REGISTER(...) /*qc2rust::macro_begin::REGISTER*/EVAL_REGISTER(OVERLOAD_(REGISTER,  /*qc2rust::param_begin::__VA_ARGS__*/__VA_ARGS__ /*qc2rust::param_end::__VA_ARGS__*/)) /*qc2rust::macro_end::REGISTER*/
/*qc2rust::define::EVAL_REGISTER*/
#define EVAL_REGISTER(...) /*qc2rust::macro_begin::EVAL_REGISTER*/ /*qc2rust::param_begin::__VA_ARGS__*/__VA_ARGS__ /*qc2rust::param_end::__VA_ARGS__*/ /*qc2rust::macro_end::EVAL_REGISTER*/
#define REGISTER_5(registry, ns, id, fld, inst) REGISTER_4(registry, ns##_##id, fld, inst)
#define REGISTER_4(registry, id, fld, inst) 	entity id; 	REGISTER_INIT(id) {} 	void Register_##id() 	{ 		entity this = id; 		if (this == NULL) { 			_regCheck(registry##_COUNT, registry##_MAX); 			this = id = inst; 			this.registered_id = #id; 			REGISTRY_PUSH(registry, fld, this); 		} 		Register_##id##_init(this); 	} 	ACCUMULATE_FUNCTION(_Register##registry, Register_##id) 	REGISTER_INIT(id)

#define REGISTRY_PUSH(registry, fld, it) MACRO_BEGIN 	it.fld = registry##_COUNT; 	_R_SET(_##registry, registry##_COUNT, it); 	++registry##_COUNT; 	if (!registry##_first) registry##_first = it; 	if (registry##_last)   registry##_last.REGISTRY_NEXT = it; 	registry##_last = it; MACRO_END

/*qc2rust::define::REGISTRY_RESERVE*/
#define REGISTRY_RESERVE(registry,fld,id,suffix) /*qc2rust::macro_begin::REGISTRY_RESERVE*/MACRO_BEGIN 	entity e = new_pure(registry_reserved); 	e.registered_id =  /*qc2rust::stringify_begin::id*/#id /*qc2rust::stringify_end::id*/ "/"  /*qc2rust::stringify_begin::suffix*/#suffix /*qc2rust::stringify_end::suffix*/; 	REGISTRY_PUSH( /*qc2rust::param_begin::registry*/registry /*qc2rust::param_end::registry*/,  /*qc2rust::param_begin::fld*/fld /*qc2rust::param_end::fld*/, e); MACRO_END /*qc2rust::macro_end::REGISTRY_RESERVE*/

#define REGISTER_INIT(id) ACCUMULATE void Register_##id##_init(entity this)

/** internal next pointer */
/*qc2rust::define::REGISTRY_NEXT*/
#define REGISTRY_NEXT /*qc2rust::macro_begin::REGISTRY_NEXT*/enemy /*qc2rust::macro_end::REGISTRY_NEXT*/
.entity REGISTRY_NEXT;

/*qc2rust::define::REGISTRY_SORT*/
#define REGISTRY_SORT(...) /*qc2rust::macro_begin::REGISTRY_SORT*/EVAL_REGISTRY_SORT(OVERLOAD(REGISTRY_SORT,  /*qc2rust::param_begin::__VA_ARGS__*/__VA_ARGS__ /*qc2rust::param_end::__VA_ARGS__*/)) /*qc2rust::macro_end::REGISTRY_SORT*/
/*qc2rust::define::EVAL_REGISTRY_SORT*/
#define EVAL_REGISTRY_SORT(...) /*qc2rust::macro_begin::EVAL_REGISTRY_SORT*/ /*qc2rust::param_begin::__VA_ARGS__*/__VA_ARGS__ /*qc2rust::param_end::__VA_ARGS__*/ /*qc2rust::macro_end::EVAL_REGISTRY_SORT*/
/*qc2rust::define::REGISTRY_SORT_1*/
#define REGISTRY_SORT_1(id) /*qc2rust::macro_begin::REGISTRY_SORT_1*/REGISTRY_SORT_2( /*qc2rust::param_begin::id*/id /*qc2rust::param_end::id*/, 0) /*qc2rust::macro_end::REGISTRY_SORT_1*/
#define REGISTRY_SORT_2(id, skip) 	void _REGISTRY_SWAP_##id(int i, int j, entity pass) 	{ 		i += skip; j += skip; 				entity a = _R_GET(_##id, i), b = _R_GET(_##id, j); 		_R_SET(_##id, i, b); 		_R_SET(_##id, j, a);         		entity a_next = a.REGISTRY_NEXT, b_next = b.REGISTRY_NEXT; 		a.REGISTRY_NEXT = b_next; 		b.REGISTRY_NEXT = a_next;         		if (i == 0) id##_first = b; 		else _R_GET(_##id, i - 1).REGISTRY_NEXT = b;         		if (j == 0) id##_first = a; 		else _R_GET(_##id, j - 1).REGISTRY_NEXT = a; 	} 	int _REGISTRY_CMP_##id(int i, int j, entity pass) 	{ 		i += skip; j += skip; 		string a = _R_GET(_##id, i).registered_id; 		string b = _R_GET(_##id, j).registered_id; 		return strcmp(a, b); 	} 	STATIC_INIT(Registry_sort_##id) 	{ 		heapsort(id##_COUNT - (skip), _REGISTRY_SWAP_##id, _REGISTRY_CMP_##id, NULL); 	}

#define REGISTRY_HASH(id) Registry_hash_##id

ERASEABLE
ACCUMULATE void Registry_check(string r, string server) { }
ERASEABLE
ACCUMULATE void Registry_send_all() { }

#ifdef SVQC
void Registry_send(string id, string hash);
#else
/*qc2rust::define::Registry_send*/
#define Registry_send(id,hash) /*qc2rust::macro_begin::Registry_send*/ /*qc2rust::macro_end::Registry_send*/
#endif

#define REGISTRY_CHECK(id) 	string REGISTRY_HASH(id); 	STATIC_INIT(Registry_check_##id) 	{ 		/* Note: SHA256 isn't always available, use MD4 instead */ 		string s = "", join = ":"; 		FOREACH(id, true, s = strcat(s, join, it.registered_id)); 		s = substring(s, strlen(join), -1); 		string h = REGISTRY_HASH(id) = strzone(digest_hex("MD4", s)); 		LOG_DEBUGF(#id ": %s\n[%s]", h, s); 	} 	void Registry_check(string r, string sv) 	{ 		if (r == #id) 		{ 			string cl = REGISTRY_HASH(id); 			if (cl != sv) 			{ 				LOG_FATALF("client/server mismatch (%s).\nCL: %s\nSV: %s", r, cl, sv); 			} 		} 	} 	void Registry_send_all() { Registry_send(#id, REGISTRY_HASH(id)); } 
/*qc2rust::define::REGISTER_REGISTRY*/
#define REGISTER_REGISTRY(...) /*qc2rust::macro_begin::REGISTER_REGISTRY*/EVAL_REGISTER_REGISTRY(OVERLOAD(REGISTER_REGISTRY,  /*qc2rust::param_begin::__VA_ARGS__*/__VA_ARGS__ /*qc2rust::param_end::__VA_ARGS__*/)) /*qc2rust::macro_end::REGISTER_REGISTRY*/
/*qc2rust::define::EVAL_REGISTER_REGISTRY*/
#define EVAL_REGISTER_REGISTRY(...) /*qc2rust::macro_begin::EVAL_REGISTER_REGISTRY*/ /*qc2rust::param_begin::__VA_ARGS__*/__VA_ARGS__ /*qc2rust::param_end::__VA_ARGS__*/ /*qc2rust::macro_end::EVAL_REGISTER_REGISTRY*/
/*qc2rust::define::REGISTER_REGISTRY_1*/
#define REGISTER_REGISTRY_1(id) /*qc2rust::macro_begin::REGISTER_REGISTRY_1*/REGISTER_REGISTRY_2( /*qc2rust::param_begin::id*/id /*qc2rust::param_end::id*/,  /*qc2rust::stringify_begin::id*/#id /*qc2rust::stringify_end::id*/) /*qc2rust::macro_end::REGISTER_REGISTRY_1*/
#define REGISTER_REGISTRY_2(id, str) 	ACCUMULATE_FUNCTION(__static_init_1, Register##id) 	CLASS(id##Registry, Object) 		ATTRIB(id##Registry, m_name, string, str); 		ATTRIB(id##Registry, REGISTRY_NEXT, entity, id##_first); 		METHOD(id##Registry, m_reload, void()); 	ENDCLASS(id##Registry) 	REGISTER(Registries, REGISTRY, id, m_id, NEW(id##Registry)); 	METHOD(id##Registry, m_reload, void()) { 	    id##_state = 0; 		Register##id(); 	}
