#pragma once

#include <common/mutators/base.qh>

// register all possible hooks here

// to use a hook, first register your mutator using REGISTER_MUTATOR
// then create your function using MUTATOR_HOOKFUNCTION

/** called when a player becomes observer, after shared setup */
/*qc2rust::define::EV_MakePlayerObserver*/
#define EV_MakePlayerObserver(i,o) /*qc2rust::macro_begin::EV_MakePlayerObserver*//** player */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_MakePlayerObserver*/
MUTATOR_HOOKABLE(MakePlayerObserver, EV_MakePlayerObserver)

/** */
/*qc2rust::define::EV_PutClientInServer*/
#define EV_PutClientInServer(i,o) /*qc2rust::macro_begin::EV_PutClientInServer*//** client wanting to spawn */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_PutClientInServer*/
MUTATOR_HOOKABLE(PutClientInServer, EV_PutClientInServer);

/**
 * return true to prevent a spectator/observer to spawn as player
 */
/*qc2rust::define::EV_ForbidSpawn*/
#define EV_ForbidSpawn(i,o) /*qc2rust::macro_begin::EV_ForbidSpawn*//** player */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_ForbidSpawn*/
MUTATOR_HOOKABLE(ForbidSpawn, EV_ForbidSpawn);

/** returns true if client should be put as player on connection */
/*qc2rust::define::EV_AutoJoinOnConnection*/
#define EV_AutoJoinOnConnection(i,o) /*qc2rust::macro_begin::EV_AutoJoinOnConnection*//** player */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_AutoJoinOnConnection*/
MUTATOR_HOOKABLE(AutoJoinOnConnection, EV_AutoJoinOnConnection);

/** called when player spawns to determine whether to give them random start weapons. Return true to forbid giving them. */
/*qc2rust::define::EV_ForbidRandomStartWeapons*/
#define EV_ForbidRandomStartWeapons(i,o) /*qc2rust::macro_begin::EV_ForbidRandomStartWeapons*//** player */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_ForbidRandomStartWeapons*/
MUTATOR_HOOKABLE(ForbidRandomStartWeapons, EV_ForbidRandomStartWeapons);

/** called when a player spawns as player, after shared setup, before his weapon is chosen (so items may be changed in here) */
/*qc2rust::define::EV_PlayerSpawn*/
#define EV_PlayerSpawn(i,o) /*qc2rust::macro_begin::EV_PlayerSpawn*//** player spawning */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** spot that was used, or NULL */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /**/ /*qc2rust::macro_end::EV_PlayerSpawn*/
MUTATOR_HOOKABLE(PlayerSpawn, EV_PlayerSpawn);

/** called after a player's weapon is chosen so it can be overriden here */
/*qc2rust::define::EV_PlayerWeaponSelect*/
#define EV_PlayerWeaponSelect(i,o) /*qc2rust::macro_begin::EV_PlayerWeaponSelect*//** player spawning */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_PlayerWeaponSelect*/
MUTATOR_HOOKABLE(PlayerWeaponSelect, EV_PlayerWeaponSelect);

/** called in reset_map */
/*qc2rust::define::EV_reset_map_global*/
#define EV_reset_map_global(i,o) /*qc2rust::macro_begin::EV_reset_map_global*//**/ /*qc2rust::macro_end::EV_reset_map_global*/
MUTATOR_HOOKABLE(reset_map_global, EV_reset_map_global);

/** called in reset_map */
/*qc2rust::define::EV_reset_map_players*/
#define EV_reset_map_players(i,o) /*qc2rust::macro_begin::EV_reset_map_players*//**/ /*qc2rust::macro_end::EV_reset_map_players*/
MUTATOR_HOOKABLE(reset_map_players, EV_reset_map_players);

/** returns 1 if clearing player score shall not be allowed */
/*qc2rust::define::EV_ForbidPlayerScore_Clear*/
#define EV_ForbidPlayerScore_Clear(i,o) /*qc2rust::macro_begin::EV_ForbidPlayerScore_Clear*//**/ /*qc2rust::macro_end::EV_ForbidPlayerScore_Clear*/
MUTATOR_HOOKABLE(ForbidPlayerScore_Clear, EV_ForbidPlayerScore_Clear);

/** called when a player disconnects */
/*qc2rust::define::EV_ClientDisconnect*/
#define EV_ClientDisconnect(i,o) /*qc2rust::macro_begin::EV_ClientDisconnect*//** player */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_ClientDisconnect*/
MUTATOR_HOOKABLE(ClientDisconnect, EV_ClientDisconnect);

/** called when a player dies to e.g. remove stuff he was carrying. */
/*qc2rust::define::EV_PlayerDies*/
#define EV_PlayerDies(i,o) /*qc2rust::macro_begin::EV_PlayerDies*//** inflictor  		*/  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** attacker    	*/  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /** target    		*/  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_2_entity)     /** deathtype     	*/  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float,  MUTATOR_ARGV_3_float)     /** damage         */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float,  MUTATOR_ARGV_4_float)     /** damage  		*/  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float,  MUTATOR_ARGV_4_float)     /**/ /*qc2rust::macro_end::EV_PlayerDies*/
MUTATOR_HOOKABLE(PlayerDies, EV_PlayerDies);

/** called after a player died. */
/*qc2rust::define::EV_PlayerDied*/
#define EV_PlayerDied(i,o) /*qc2rust::macro_begin::EV_PlayerDied*//** player    		*/  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_PlayerDied*/
MUTATOR_HOOKABLE(PlayerDied, EV_PlayerDied);

/** allows overriding the frag centerprint messages */
/*qc2rust::define::EV_FragCenterMessage*/
#define EV_FragCenterMessage(i,o) /*qc2rust::macro_begin::EV_FragCenterMessage*//** attacker       */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** target         */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /** deathtype      */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_2_float)     /** attacker kcount*/  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int,  MUTATOR_ARGV_3_int)     /** targ killcount */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int,  MUTATOR_ARGV_4_int)     /**/ /*qc2rust::macro_end::EV_FragCenterMessage*/
MUTATOR_HOOKABLE(FragCenterMessage, EV_FragCenterMessage);

/** called when a player dies to e.g. remove stuff he was carrying */
/*qc2rust::define::EV_PlayHitsound*/
#define EV_PlayHitsound(i,o) /*qc2rust::macro_begin::EV_PlayHitsound*//** victim */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** attacker */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /**/ /*qc2rust::macro_end::EV_PlayHitsound*/
MUTATOR_HOOKABLE(PlayHitsound, EV_PlayHitsound);

/** called when an item model is about to be set, allows custom paths etc. */
/*qc2rust::define::EV_ItemModel*/
#define EV_ItemModel(i,o) /*qc2rust::macro_begin::EV_ItemModel*//** model       */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_0_string)     /** output      */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_1_string)     /**/                /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(string, MUTATOR_ARGV_1_string)     /**/ /*qc2rust::macro_end::EV_ItemModel*/
MUTATOR_HOOKABLE(ItemModel, EV_ItemModel);

/** called when an item sound is about to be played, allows custom paths etc. */
/*qc2rust::define::EV_ItemSound*/
#define EV_ItemSound(i,o) /*qc2rust::macro_begin::EV_ItemSound*//** sound       */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_0_string)     /** output      */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_1_string)     /**/                /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(string, MUTATOR_ARGV_1_string)     /**/ /*qc2rust::macro_end::EV_ItemSound*/
MUTATOR_HOOKABLE(ItemSound, EV_ItemSound);

/** called when someone was fragged by "self", and is expected to change frag_score to adjust scoring for the kill */
/*qc2rust::define::EV_GiveFragsForKill*/
#define EV_GiveFragsForKill(i,o) /*qc2rust::macro_begin::EV_GiveFragsForKill*//** attacker   */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** target     */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /** frag score */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_2_float)     /**            */  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_2_float)     /** deathtype  */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_3_float)     /** wep entity */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_4_entity)     /**/ /*qc2rust::macro_end::EV_GiveFragsForKill*/
MUTATOR_HOOKABLE(GiveFragsForKill, EV_GiveFragsForKill);

/** called when the match ends */
MUTATOR_HOOKABLE(MatchEnd, EV_NO_ARGS);

/** Allows adjusting allowed teams. Return true to use the bitmask value and set
 * non-empty string to use team entity name. Both behaviors can be active at the
 * same time and will stack allowed teams.
 */
/*qc2rust::define::EV_TeamBalance_CheckAllowedTeams*/
#define EV_TeamBalance_CheckAllowedTeams(i,o) /*qc2rust::macro_begin::EV_TeamBalance_CheckAllowedTeams*//** mask of teams      */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_0_float)     /**/                       /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_0_float)     /** team entity name   */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_1_string)     /**/                       /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(string, MUTATOR_ARGV_1_string)     /** player checked     */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_2_entity)     /**/ /*qc2rust::macro_end::EV_TeamBalance_CheckAllowedTeams*/
MUTATOR_HOOKABLE(TeamBalance_CheckAllowedTeams,
	EV_TeamBalance_CheckAllowedTeams);

/** return true to manually override team counts */
MUTATOR_HOOKABLE(TeamBalance_GetTeamCounts, EV_NO_ARGS);

/** allows overriding of team counts */
/*qc2rust::define::EV_TeamBalance_GetTeamCount*/
#define EV_TeamBalance_GetTeamCount(i,o) /*qc2rust::macro_begin::EV_TeamBalance_GetTeamCount*//** team index to count             */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_0_float)     /** player to ignore                */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /** number of players in a team     */  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_2_float)     /** number of bots in a team        */  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_3_float)     /**/ /*qc2rust::macro_end::EV_TeamBalance_GetTeamCount*/
MUTATOR_HOOKABLE(TeamBalance_GetTeamCount, EV_TeamBalance_GetTeamCount);

/** allows overriding the teams that will make the game most balanced if the
 *  player joins any of them.
 */
/*qc2rust::define::EV_TeamBalance_FindBestTeams*/
#define EV_TeamBalance_FindBestTeams(i,o) /*qc2rust::macro_begin::EV_TeamBalance_FindBestTeams*//** player checked   */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** bitmask of teams */  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_1_float)     /**/ /*qc2rust::macro_end::EV_TeamBalance_FindBestTeams*/
MUTATOR_HOOKABLE(TeamBalance_FindBestTeams, EV_TeamBalance_FindBestTeams);

/** Called during autobalance. Return true to override the player that will be
switched. */
/*qc2rust::define::EV_TeamBalance_GetPlayerForTeamSwitch*/
#define EV_TeamBalance_GetPlayerForTeamSwitch(i,o) /*qc2rust::macro_begin::EV_TeamBalance_GetPlayerForTeamSwitch*//** source team index      */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_0_int)     /** destination team index */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_1_int)     /** is looking for bot     */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(bool, MUTATOR_ARGV_2_bool)     /** player to switch       */  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(entity, MUTATOR_ARGV_3_entity)     /**/ /*qc2rust::macro_end::EV_TeamBalance_GetPlayerForTeamSwitch*/
MUTATOR_HOOKABLE(TeamBalance_GetPlayerForTeamSwitch,
	EV_TeamBalance_GetPlayerForTeamSwitch);

/** copies variables for spectating "spectatee" to "this" */
/*qc2rust::define::EV_SpectateCopy*/
#define EV_SpectateCopy(i,o) /*qc2rust::macro_begin::EV_SpectateCopy*//** spectatee   */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** client      */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /**/ /*qc2rust::macro_end::EV_SpectateCopy*/
MUTATOR_HOOKABLE(SpectateCopy, EV_SpectateCopy);

/** called when formatting a chat message to replace fancy functions */
/*qc2rust::define::EV_FormatMessage*/
#define EV_FormatMessage(i,o) /*qc2rust::macro_begin::EV_FormatMessage*//** player        */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** escape        */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_1_string)     /** replacement   */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_2_string)     /**/                  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(string, MUTATOR_ARGV_2_string)     /** message       */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_3_string)     /**/ /*qc2rust::macro_end::EV_FormatMessage*/
MUTATOR_HOOKABLE(FormatMessage, EV_FormatMessage);

/** called before any formatting is applied, handy for tweaking the message before scripts get ahold of it */
/*qc2rust::define::EV_PreFormatMessage*/
#define EV_PreFormatMessage(i,o) /*qc2rust::macro_begin::EV_PreFormatMessage*//** player        */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** message       */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_1_string)     /**/                  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(string, MUTATOR_ARGV_1_string)     /**/ /*qc2rust::macro_end::EV_PreFormatMessage*/
MUTATOR_HOOKABLE(PreFormatMessage, EV_PreFormatMessage);

/** returns true if throwing the current weapon shall not be allowed */
/*qc2rust::define::EV_ForbidThrowCurrentWeapon*/
#define EV_ForbidThrowCurrentWeapon(i,o) /*qc2rust::macro_begin::EV_ForbidThrowCurrentWeapon*//** player        */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** weapon entity */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /**/ /*qc2rust::macro_end::EV_ForbidThrowCurrentWeapon*/
MUTATOR_HOOKABLE(ForbidThrowCurrentWeapon, EV_ForbidThrowCurrentWeapon);

/** returns true if dropping the current weapon shall not be allowed at any time including death */
/*qc2rust::define::EV_ForbidDropCurrentWeapon*/
#define EV_ForbidDropCurrentWeapon(i,o) /*qc2rust::macro_begin::EV_ForbidDropCurrentWeapon*//** player */         /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** weapon id */      /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_1_int)     /**/ /*qc2rust::macro_end::EV_ForbidDropCurrentWeapon*/
MUTATOR_HOOKABLE(ForbidDropCurrentWeapon, EV_ForbidDropCurrentWeapon);

/**  */
MUTATOR_HOOKABLE(SetDefaultAlpha, EV_NO_ARGS);

/** allows changing attack rate */
/*qc2rust::define::EV_WeaponRateFactor*/
#define EV_WeaponRateFactor(i,o) /*qc2rust::macro_begin::EV_WeaponRateFactor*//** weapon rate */   /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_0_float)     /**/                 /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_0_float)     /** player */        /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /**/ /*qc2rust::macro_end::EV_WeaponRateFactor*/
MUTATOR_HOOKABLE(WeaponRateFactor, EV_WeaponRateFactor);

/** allows changing weapon speed (projectiles mostly) */
/*qc2rust::define::EV_WeaponSpeedFactor*/
#define EV_WeaponSpeedFactor(i,o) /*qc2rust::macro_begin::EV_WeaponSpeedFactor*//** weapon speed */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_0_float)     /**/                 /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_0_float)     /** player */        /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /**/ /*qc2rust::macro_end::EV_WeaponSpeedFactor*/
MUTATOR_HOOKABLE(WeaponSpeedFactor, EV_WeaponSpeedFactor);

/** adjusts {warmup_}start_{items,weapons,ammo_{cells,plasma,rockets,nails,shells,fuel}} */
MUTATOR_HOOKABLE(SetStartItems, EV_NO_ARGS);

/** called every frame. customizes the waypoint for spectators */
/*qc2rust::define::EV_CustomizeWaypoint*/
#define EV_CustomizeWaypoint(i,o) /*qc2rust::macro_begin::EV_CustomizeWaypoint*//** waypoint                        */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** player; other.enemy = spectator */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /**/ /*qc2rust::macro_end::EV_CustomizeWaypoint*/
MUTATOR_HOOKABLE(CustomizeWaypoint, EV_CustomizeWaypoint);

/** Check if items having the given definition are allowed to spawn.
 *  Return true to disallow spawning.
 */
/*qc2rust::define::EV_FilterItemDefinition*/
#define EV_FilterItemDefinition(i,o) /*qc2rust::macro_begin::EV_FilterItemDefinition*//** item        */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_FilterItemDefinition*/
MUTATOR_HOOKABLE(FilterItemDefinition, EV_FilterItemDefinition);

/**
 * checks if the current item may be spawned (.items may be read and written to, as well as the ammo_ fields)
 * return error to request removal
 */
/*qc2rust::define::EV_FilterItem*/
#define EV_FilterItem(i,o) /*qc2rust::macro_begin::EV_FilterItem*//** item        */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_FilterItem*/
MUTATOR_HOOKABLE(FilterItem, EV_FilterItem);

/** return error to request removal */
/*qc2rust::define::EV_TurretSpawn*/
#define EV_TurretSpawn(i,o) /*qc2rust::macro_begin::EV_TurretSpawn*//** turret        */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_TurretSpawn*/
MUTATOR_HOOKABLE(TurretSpawn, EV_TurretSpawn);

/** return error to not attack */
/*qc2rust::define::EV_TurretFire*/
#define EV_TurretFire(i,o) /*qc2rust::macro_begin::EV_TurretFire*//** turret        */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_TurretFire*/
MUTATOR_HOOKABLE(TurretFire, EV_TurretFire);

/** return error to not attack */
/*qc2rust::define::EV_Turret_CheckFire*/
#define EV_Turret_CheckFire(i,o) /*qc2rust::macro_begin::EV_Turret_CheckFire*//** turret                      */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** to fire or not to fire      */  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(bool, MUTATOR_ARGV_1_bool)     /**/ /*qc2rust::macro_end::EV_Turret_CheckFire*/
MUTATOR_HOOKABLE(Turret_CheckFire, EV_Turret_CheckFire);

/** return error to prevent entity spawn, or modify the entity */
/*qc2rust::define::EV_OnEntityPreSpawn*/
#define EV_OnEntityPreSpawn(i,o) /*qc2rust::macro_begin::EV_OnEntityPreSpawn*//** entity  */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_OnEntityPreSpawn*/
MUTATOR_HOOKABLE(OnEntityPreSpawn, EV_OnEntityPreSpawn);

/** runs in the event loop for players; is called for ALL player entities, also bots, also the dead, or spectators */
/*qc2rust::define::EV_PlayerPreThink*/
#define EV_PlayerPreThink(i,o) /*qc2rust::macro_begin::EV_PlayerPreThink*//** player */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_PlayerPreThink*/
MUTATOR_HOOKABLE(PlayerPreThink, EV_PlayerPreThink);

/** TODO change this into a general PlayerPostThink hook? */
/*qc2rust::define::EV_GetPressedKeys*/
#define EV_GetPressedKeys(i,o) /*qc2rust::macro_begin::EV_GetPressedKeys*//** player */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_GetPressedKeys*/
MUTATOR_HOOKABLE(GetPressedKeys, EV_GetPressedKeys);

/** is meant to call GetCvars_handle*(get_cvars_s, get_cvars_f, cvarfield, "cvarname") for cvars this mutator needs from the client */
/*qc2rust::define::EV_GetCvars*/
#define EV_GetCvars(i,o) /*qc2rust::macro_begin::EV_GetCvars*//**/  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, get_cvars_f)     /**/  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, get_cvars_s)     /**/ /*qc2rust::macro_end::EV_GetCvars*/
float get_cvars_f;
string get_cvars_s;
MUTATOR_HOOKABLE(GetCvars, EV_NO_ARGS); // NOTE: Can't use EV_GetCvars because of `SZ_GetSpace: overflow`

/** can edit any "just fired" projectile */
/*qc2rust::define::EV_EditProjectile*/
#define EV_EditProjectile(i,o) /*qc2rust::macro_begin::EV_EditProjectile*//** projectile owner */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** projectile */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /**/ /*qc2rust::macro_end::EV_EditProjectile*/
MUTATOR_HOOKABLE(EditProjectile, EV_EditProjectile);

/** called when a monster spawns */
/*qc2rust::define::EV_MonsterSpawn*/
#define EV_MonsterSpawn(i,o) /*qc2rust::macro_begin::EV_MonsterSpawn*//** monster */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_MonsterSpawn*/
MUTATOR_HOOKABLE(MonsterSpawn, EV_MonsterSpawn);

/** called when a monster dies */
/*qc2rust::define::EV_MonsterDies*/
#define EV_MonsterDies(i,o) /*qc2rust::macro_begin::EV_MonsterDies*//** target       */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** attacker     */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /** deathtype    */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_2_float)     /**/ /*qc2rust::macro_end::EV_MonsterDies*/
MUTATOR_HOOKABLE(MonsterDies, EV_MonsterDies);

/** called when a monster dies */
/*qc2rust::define::EV_MonsterRemove*/
#define EV_MonsterRemove(i,o) /*qc2rust::macro_begin::EV_MonsterRemove*//** monster */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_MonsterRemove*/
MUTATOR_HOOKABLE(MonsterRemove, EV_MonsterRemove);

/** called when a monster wants to respawn */
/*qc2rust::define::EV_MonsterRespawn*/
#define EV_MonsterRespawn(i,o) /*qc2rust::macro_begin::EV_MonsterRespawn*//** monster */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_MonsterRespawn*/
MUTATOR_HOOKABLE(MonsterRespawn, EV_MonsterRespawn);

/** called when a monster is dropping loot */
/*qc2rust::define::EV_MonsterDropItem*/
#define EV_MonsterDropItem(i,o) /*qc2rust::macro_begin::EV_MonsterDropItem*//* monster */                           /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /* item (can be removed or changed) */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /**/                                    /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(entity, MUTATOR_ARGV_1_entity)     /* attacker */                          /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_2_entity)     /**/ /*qc2rust::macro_end::EV_MonsterDropItem*/
.entity monster_loot;
MUTATOR_HOOKABLE(MonsterDropItem, EV_MonsterDropItem);

/**
 * called when a monster moves
 * returning true makes the monster stop
 */
/*qc2rust::define::EV_MonsterMove*/
#define EV_MonsterMove(i,o) /*qc2rust::macro_begin::EV_MonsterMove*//** monster */        /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** run speed */      /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_1_float)     /**/                  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_1_float)     /** walk speed */     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_2_float)     /**/                  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_2_float)     /** move target */    /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_3_entity)     /**/                  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(entity, MUTATOR_ARGV_3_entity)     /**/ /*qc2rust::macro_end::EV_MonsterMove*/
MUTATOR_HOOKABLE(MonsterMove, EV_MonsterMove);

/** called when a monster looks for another target */
MUTATOR_HOOKABLE(MonsterFindTarget, EV_NO_ARGS);

/**
 * called when validating a monster's target
 */
/*qc2rust::define::EV_MonsterValidTarget*/
#define EV_MonsterValidTarget(i,o) /*qc2rust::macro_begin::EV_MonsterValidTarget*//** monster */        /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** target */         /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /**/ /*qc2rust::macro_end::EV_MonsterValidTarget*/
MUTATOR_HOOKABLE(MonsterValidTarget, EV_MonsterValidTarget);

/** called to change a random monster to a miniboss */
/*qc2rust::define::EV_MonsterCheckBossFlag*/
#define EV_MonsterCheckBossFlag(i,o) /*qc2rust::macro_begin::EV_MonsterCheckBossFlag*//** monster */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_MonsterCheckBossFlag*/
MUTATOR_HOOKABLE(MonsterCheckBossFlag, EV_MonsterCheckBossFlag);

/**
 * called when a player tries to spawn a monster
 * return 1 to prevent spawning
 * NOTE: requires reason if disallowed
 */
/*qc2rust::define::EV_AllowMobSpawning*/
#define EV_AllowMobSpawning(i,o) /*qc2rust::macro_begin::EV_AllowMobSpawning*//** caller */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** reason */  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(string, MUTATOR_ARGV_1_string)     /**/ /*qc2rust::macro_end::EV_AllowMobSpawning*/
MUTATOR_HOOKABLE(AllowMobSpawning, EV_AllowMobSpawning);

/** called when a player gets damaged to e.g. remove stuff he was carrying. */
/*qc2rust::define::EV_PlayerDamage_SplitHealthArmor*/
#define EV_PlayerDamage_SplitHealthArmor(i,o) /*qc2rust::macro_begin::EV_PlayerDamage_SplitHealthArmor*//** inflictor  		*/  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** attacker    	*/  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /** target    		*/  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_2_entity)     /** force (no out)  */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(vector, MUTATOR_ARGV_3_vector)     /** damage take     */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float,  MUTATOR_ARGV_4_float)     /** damage take  	*/  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float,  MUTATOR_ARGV_4_float)     /** damage save     */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float,  MUTATOR_ARGV_5_float)     /** damage save 	*/  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float,  MUTATOR_ARGV_5_float)     /** deathtype 		*/  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float,  MUTATOR_ARGV_6_float)     /** damage 		    */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float,  MUTATOR_ARGV_7_float)     /**/ /*qc2rust::macro_end::EV_PlayerDamage_SplitHealthArmor*/
MUTATOR_HOOKABLE(PlayerDamage_SplitHealthArmor, EV_PlayerDamage_SplitHealthArmor);

/**
 * called to adjust damage and force values which are applied to the player, used for e.g. strength damage/force multiplier
 * i'm not sure if I should change this around slightly (Naming of the entities, and also how they're done in g_damage).
 */
/*qc2rust::define::EV_Damage_Calculate*/
#define EV_Damage_Calculate(i,o) /*qc2rust::macro_begin::EV_Damage_Calculate*//** inflictor  		*/  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** attacker    	*/  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /** target    		*/  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_2_entity)     /** deathtype     	*/  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float,  MUTATOR_ARGV_3_float)     /** damage          */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float,  MUTATOR_ARGV_4_float)     /** damage  		*/  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float,  MUTATOR_ARGV_4_float)     /** mirrordamage    */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float,  MUTATOR_ARGV_5_float)     /** mirrordamage 	*/  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float,  MUTATOR_ARGV_5_float)     /** force           */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(vector, MUTATOR_ARGV_6_vector)     /** force           */  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(vector, MUTATOR_ARGV_6_vector)     /** weapon entity 	*/  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_7_entity)     /**/ /*qc2rust::macro_end::EV_Damage_Calculate*/
MUTATOR_HOOKABLE(Damage_Calculate, EV_Damage_Calculate);

/**
 * Called when a player is damaged
 */
/*qc2rust::define::EV_PlayerDamaged*/
#define EV_PlayerDamaged(i,o) /*qc2rust::macro_begin::EV_PlayerDamaged*//** attacker  */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** target    */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /** health    */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float,    MUTATOR_ARGV_2_float)     /** armor     */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float,    MUTATOR_ARGV_3_float)     /** location  */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(vector, MUTATOR_ARGV_4_vector)     /** deathtype */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int,    MUTATOR_ARGV_5_int)     /** potential_damage     */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float,    MUTATOR_ARGV_6_float)     /**/ /*qc2rust::macro_end::EV_PlayerDamaged*/
MUTATOR_HOOKABLE(PlayerDamaged, EV_PlayerDamaged);

/**
 * Called by W_DecreaseAmmo
 */
/*qc2rust::define::EV_W_DecreaseAmmo*/
#define EV_W_DecreaseAmmo(i,o) /*qc2rust::macro_begin::EV_W_DecreaseAmmo*//** actor */             /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** weapon entity */     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /** ammo to take */      /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_2_float)     /**/                     /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_2_float)     /**/ /*qc2rust::macro_end::EV_W_DecreaseAmmo*/
MUTATOR_HOOKABLE(W_DecreaseAmmo, EV_W_DecreaseAmmo);

/**
 * Called by W_Reload
 */
/*qc2rust::define::EV_W_Reload*/
#define EV_W_Reload(i,o) /*qc2rust::macro_begin::EV_W_Reload*//** actor */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_W_Reload*/
MUTATOR_HOOKABLE(W_Reload, EV_W_Reload);

/** called at the end of player_powerups() in client.qc, used for manipulating the values which are set by powerup items. */
/*qc2rust::define::EV_PlayerPowerups*/
#define EV_PlayerPowerups(i,o) /*qc2rust::macro_begin::EV_PlayerPowerups*//** player */     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** old items */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_1_int)     /**/ /*qc2rust::macro_end::EV_PlayerPowerups*/
MUTATOR_HOOKABLE(PlayerPowerups, EV_PlayerPowerups);

/**
 * called every player think frame
 * return 1 to disable regen
 */
/*qc2rust::define::EV_PlayerRegen*/
#define EV_PlayerRegen(i,o) /*qc2rust::macro_begin::EV_PlayerRegen*//** player */                /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** max_mod */               /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_1_float)     /**/                         /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_1_float)     /** regen_mod */             /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_2_float)     /**/                         /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_2_float)     /** rot_mod */               /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_3_float)     /**/                         /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_3_float)     /** limit_mod */             /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_4_float)     /**/                         /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_4_float)     /** health_regen */          /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_5_float)     /**/                         /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_5_float)     /** health_regenlinear */    /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_6_float)     /**/                         /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_6_float)     /** health_rot */            /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_7_float)     /**/                         /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_7_float)     /** health_rotlinear */      /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_8_float)     /**/                         /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_8_float)     /** health_stable */         /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_9_float)     /**/                         /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_9_float)     /** health_rotstable */      /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_10_float)     /**/                         /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_10_float)     /**/ /*qc2rust::macro_end::EV_PlayerRegen*/
MUTATOR_HOOKABLE(PlayerRegen, EV_PlayerRegen);

/**
 * called when the use key is pressed
 * if MUTATOR_RETURNVALUE is 1, don't do anything
 * return 1 if the use key actually did something
 */
/*qc2rust::define::EV_PlayerUseKey*/
#define EV_PlayerUseKey(i,o) /*qc2rust::macro_begin::EV_PlayerUseKey*//** player */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_PlayerUseKey*/
MUTATOR_HOOKABLE(PlayerUseKey, EV_PlayerUseKey);

/**
 * called when a client command is parsed
 * NOTE: hooks MUST start with if (MUTATOR_RETURNVALUE) return false;
 * NOTE: return true if you handled the command, return false to continue handling
 * NOTE: THESE HOOKS MUST NEVER EVER CALL tokenize()
 * // example:
 * MUTATOR_HOOKFUNCTION(foo_SV_ParseClientCommand)
 * {
 *     if (MUTATOR_RETURNVALUE) // command was already handled?
 *         return false;
 *     if (cmd_name == "echocvar" && cmd_argc >= 2)
 *     {
 *         print(cvar_string(argv(1)), "\n");
 *         return true;
 *     }
 *     if (cmd_name == "echostring" && cmd_argc >= 2)
 *     {
 *         print(substring(cmd_string, argv_start_index(1), argv_end_index(-1) - argv_start_index(1)), "\n");
 *         return true;
 *     }
 *     return false;
 * }
 */
/*qc2rust::define::EV_SV_ParseClientCommand*/
#define EV_SV_ParseClientCommand(i,o) /*qc2rust::macro_begin::EV_SV_ParseClientCommand*//** client sending the command */        /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** command name */                      /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_1_string)  	/** argc (also, argv() can be used) */   /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_2_int)  	/** whole command, use only if you really have to */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_3_string)     /**/ /*qc2rust::macro_end::EV_SV_ParseClientCommand*/
MUTATOR_HOOKABLE(SV_ParseClientCommand, EV_SV_ParseClientCommand);

/** please read EV_SV_ParseClientCommand description before using */
/*qc2rust::define::EV_SV_ParseServerCommand*/
#define EV_SV_ParseServerCommand(i,o) /*qc2rust::macro_begin::EV_SV_ParseServerCommand*//** command name */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_0_string)  	/** argc (also, argv() can be used) */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_1_int)  	/** whole command, use only if you really have to */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_2_string)     /**/ /*qc2rust::macro_end::EV_SV_ParseServerCommand*/
MUTATOR_HOOKABLE(SV_ParseServerCommand, EV_SV_ParseServerCommand);

/**
 * called when a spawnpoint is being evaluated
 * return 1 to make the spawnpoint unusable
 */
/*qc2rust::define::EV_Spawn_Score*/
#define EV_Spawn_Score(i,o) /*qc2rust::macro_begin::EV_Spawn_Score*//** player wanting to spawn */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** spot to be evaluated */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /** spot score, _x is priority, _y is "distance" */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(vector, MUTATOR_ARGV_2_vector)     /**/  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(vector, MUTATOR_ARGV_2_vector)     /**/ /*qc2rust::macro_end::EV_Spawn_Score*/
MUTATOR_HOOKABLE(Spawn_Score, EV_Spawn_Score);

/** runs globally each server frame */
MUTATOR_HOOKABLE(SV_StartFrame, EV_NO_ARGS);

/*qc2rust::define::EV_SetModname*/
#define EV_SetModname(i,o) /*qc2rust::macro_begin::EV_SetModname*//** name of the mutator/mod if it warrants showing as such in the server browser */     /**/  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_0_string)     /**/  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(string, MUTATOR_ARGV_0_string)     /**/ /*qc2rust::macro_end::EV_SetModname*/
MUTATOR_HOOKABLE(SetModname, EV_SetModname);

/**
 * called for each item being spawned on a map, including dropped weapons
 * return 1 to remove an item
 */
/*qc2rust::define::EV_Item_Spawn*/
#define EV_Item_Spawn(i,o) /*qc2rust::macro_begin::EV_Item_Spawn*//** item */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_Item_Spawn*/
MUTATOR_HOOKABLE(Item_Spawn, EV_Item_Spawn);

/*qc2rust::define::EV_SetWeaponreplace*/
#define EV_SetWeaponreplace(i,o) /*qc2rust::macro_begin::EV_SetWeaponreplace*//** map entity */   /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** weapon info */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /** replacement */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_2_string)     /**/                /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(string, MUTATOR_ARGV_2_string)     /**/ /*qc2rust::macro_end::EV_SetWeaponreplace*/
MUTATOR_HOOKABLE(SetWeaponreplace, EV_SetWeaponreplace);

/** called when an item is about to respawn */
/*qc2rust::define::EV_Item_RespawnCountdown*/
#define EV_Item_RespawnCountdown(i,o) /*qc2rust::macro_begin::EV_Item_RespawnCountdown*//** item */    /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_Item_RespawnCountdown*/
MUTATOR_HOOKABLE(Item_RespawnCountdown, EV_Item_RespawnCountdown);

/** called when a bot checks a target to attack */
/*qc2rust::define::EV_BotShouldAttack*/
#define EV_BotShouldAttack(i,o) /*qc2rust::macro_begin::EV_BotShouldAttack*//** bot */     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** target */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /**/ /*qc2rust::macro_end::EV_BotShouldAttack*/
MUTATOR_HOOKABLE(BotShouldAttack, EV_BotShouldAttack);

/**
 * called whenever a player goes through a portal gun teleport
 * allows you to strip a player of an item if they go through the teleporter to help prevent cheating
 */
/*qc2rust::define::EV_PortalTeleport*/
#define EV_PortalTeleport(i,o) /*qc2rust::macro_begin::EV_PortalTeleport*//** player */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_PortalTeleport*/
MUTATOR_HOOKABLE(PortalTeleport, EV_PortalTeleport);

/**
 * called whenever a player uses impulse 33 (help me) in impulse.qc
 * normally help me ping uses .waypointsprite_attachedforcarrier,
 * but if your mutator uses something different then you can handle it
 * in a special manner using this hook
 */
/*qc2rust::define::EV_HelpMePing*/
#define EV_HelpMePing(i,o) /*qc2rust::macro_begin::EV_HelpMePing*//** the player who pressed impulse 33 */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_HelpMePing*/
MUTATOR_HOOKABLE(HelpMePing, EV_HelpMePing);

/**
 * called when a vehicle initializes
 * return true to remove the vehicle
 */
/*qc2rust::define::EV_VehicleInit*/
#define EV_VehicleInit(i,o) /*qc2rust::macro_begin::EV_VehicleInit*//** vehicle */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_VehicleInit*/
MUTATOR_HOOKABLE(VehicleInit, EV_VehicleInit);

/**
 * called when a player enters a vehicle
 * allows mutators to set special settings in this event
 */
/*qc2rust::define::EV_VehicleEnter*/
#define EV_VehicleEnter(i,o) /*qc2rust::macro_begin::EV_VehicleEnter*//** player */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** vehicle */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /**/ /*qc2rust::macro_end::EV_VehicleEnter*/
MUTATOR_HOOKABLE(VehicleEnter, EV_VehicleEnter);

/**
 * called when a player touches a vehicle
 * return true to stop player from entering the vehicle
 */
/*qc2rust::define::EV_VehicleTouch*/
#define EV_VehicleTouch(i,o) /*qc2rust::macro_begin::EV_VehicleTouch*//** vehicle */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** player */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /**/ /*qc2rust::macro_end::EV_VehicleTouch*/
MUTATOR_HOOKABLE(VehicleTouch, EV_VehicleTouch);

/**
 * called when a player exits a vehicle
 * allows mutators to set special settings in this event
 */
/*qc2rust::define::EV_VehicleExit*/
#define EV_VehicleExit(i,o) /*qc2rust::macro_begin::EV_VehicleExit*//** player */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** vehicle */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /**/ /*qc2rust::macro_end::EV_VehicleExit*/
MUTATOR_HOOKABLE(VehicleExit, EV_VehicleExit);

/** called when a speedrun is aborted and the player is teleported back to start position */
/*qc2rust::define::EV_AbortSpeedrun*/
#define EV_AbortSpeedrun(i,o) /*qc2rust::macro_begin::EV_AbortSpeedrun*//** player */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_AbortSpeedrun*/
MUTATOR_HOOKABLE(AbortSpeedrun, EV_AbortSpeedrun);

/** called at when a item is touched. Called early, can edit item properties. */
/*qc2rust::define::EV_ItemTouch*/
#define EV_ItemTouch(i,o) /*qc2rust::macro_begin::EV_ItemTouch*//** item */     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** toucher */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /**/            /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(entity, MUTATOR_ARGV_1_entity)     /**/ /*qc2rust::macro_end::EV_ItemTouch*/
MUTATOR_HOOKABLE(ItemTouch, EV_ItemTouch);

enum {
	MUT_ITEMTOUCH_CONTINUE, // return this flag to make the function continue as normal
	MUT_ITEMTOUCH_RETURN, // return this flag to make the function return (handled entirely by mutator)
	MUT_ITEMTOUCH_PICKUP // return this flag to have the item "picked up" and taken even after mutator handled it
};

/** called after the item has been touched. */
/*qc2rust::define::EV_ItemTouched*/
#define EV_ItemTouched(i,o) /*qc2rust::macro_begin::EV_ItemTouched*//** item */     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** toucher */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /**/ /*qc2rust::macro_end::EV_ItemTouched*/
MUTATOR_HOOKABLE(ItemTouched, EV_ItemTouched);

/** Called when the amount of entity resources changes. Can be used to override
resource limit. */
/*qc2rust::define::EV_GetResourceLimit*/
#define EV_GetResourceLimit(i,o) /*qc2rust::macro_begin::EV_GetResourceLimit*//** checked entity */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity) 	/** resource type */   /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_1_int) 	/** limit */           /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_2_float) 	/**/                   /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_2_float) 	/**/ /*qc2rust::macro_end::EV_GetResourceLimit*/
MUTATOR_HOOKABLE(GetResourceLimit, EV_GetResourceLimit);

/** Called when the amount of resource of an entity changes. See RES_*
constants for resource types. Return true to forbid the change. */
/*qc2rust::define::EV_SetResource*/
#define EV_SetResource(i,o) /*qc2rust::macro_begin::EV_SetResource*//** checked entity */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity) 	/** resource type */   /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_1_int) 	/**/                   /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(int, MUTATOR_ARGV_1_int) 	/** amount */          /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_2_float) 	/**/                   /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_2_float) 	/**/ /*qc2rust::macro_end::EV_SetResource*/
MUTATOR_HOOKABLE(SetResource, EV_SetResource);

/** Called after the amount of resource of an entity has changed. See RES_*
constants for resource types. Amount wasted is the amount of resource that is
above resource limit so it was not given. */
/*qc2rust::define::EV_ResourceAmountChanged*/
#define EV_ResourceAmountChanged(i,o) /*qc2rust::macro_begin::EV_ResourceAmountChanged*//** checked entity */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity) 	/** resource type */   /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_1_int) 	/** amount */          /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_2_float) 	/**/ /*qc2rust::macro_end::EV_ResourceAmountChanged*/
MUTATOR_HOOKABLE(ResourceAmountChanged, EV_ResourceAmountChanged);

/** Called when there was an attempt to set entity resources higher than their
limit. See RES_* constants for resource types. Amount wasted is the amount
of resource that is above resource limit so it was not given. */
/*qc2rust::define::EV_ResourceWasted*/
#define EV_ResourceWasted(i,o) /*qc2rust::macro_begin::EV_ResourceWasted*//** checked entity */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity) 	/** resource type */   /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_1_int) 	/** amount wasted */   /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_2_float) 	/**/ /*qc2rust::macro_end::EV_ResourceWasted*/
MUTATOR_HOOKABLE(ResourceWasted, EV_ResourceWasted);

/** Called when entity is being given some resource. See RES_* constants
for resource types. Return true to forbid giving.
NOTE: This hook is also called by GiveResourceWithLimit */
/*qc2rust::define::EV_GiveResource*/
#define EV_GiveResource(i,o) /*qc2rust::macro_begin::EV_GiveResource*//** receiver */       /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity) 	/** resource type */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_1_int) 	/**/                  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(int, MUTATOR_ARGV_1_int) 	/** amount */         /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_2_float) 	/**/                  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_2_float) 	/**/ /*qc2rust::macro_end::EV_GiveResource*/
MUTATOR_HOOKABLE(GiveResource, EV_GiveResource);

/** Called when entity is being given some resource with specified limit. See
RES_* constants for resource types. Return true to forbid giving. */
/*qc2rust::define::EV_GiveResourceWithLimit*/
#define EV_GiveResourceWithLimit(i,o) /*qc2rust::macro_begin::EV_GiveResourceWithLimit*//** receiver */       /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity) 	/** resource type */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_1_int) 	/**/                  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(int, MUTATOR_ARGV_1_int) 	/** amount */         /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_2_float) 	/**/                  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_2_float) 	/** limit */          /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_3_float) 	/**/                  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_3_float) 	/**/ /*qc2rust::macro_end::EV_GiveResourceWithLimit*/
MUTATOR_HOOKABLE(GiveResourceWithLimit, EV_GiveResourceWithLimit);

/** Called when some resource is being taken from an entity. See RES_* constants
for resource types. Return true to forbid giving.
NOTE: This hook is also called by TakeResourceWithLimit */
/*qc2rust::define::EV_TakeResource*/
#define EV_TakeResource(i,o) /*qc2rust::macro_begin::EV_TakeResource*//** receiver */       /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** resource type */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_1_int)     /**/                  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(int, MUTATOR_ARGV_1_int)     /** amount */         /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_2_float)     /**/                  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_2_float)     /**/ /*qc2rust::macro_end::EV_TakeResource*/
MUTATOR_HOOKABLE(TakeResource, EV_TakeResource);

/** Called when some resource is being taken from an entity, with a limit. See
RES_* constants for resource types. Return true to forbid giving. */
/*qc2rust::define::EV_TakeResourceWithLimit*/
#define EV_TakeResourceWithLimit(i,o) /*qc2rust::macro_begin::EV_TakeResourceWithLimit*//** receiver */       /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** resource type */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_1_int)     /**/                  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(int, MUTATOR_ARGV_1_int)     /** amount */         /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_2_float)     /**/                  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_2_float)     /** limit */          /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_3_float)     /**/                  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_3_float)     /**/ /*qc2rust::macro_end::EV_TakeResourceWithLimit*/
MUTATOR_HOOKABLE(TakeResourceWithLimit, EV_TakeResourceWithLimit);

/** called at when a player connect */
/*qc2rust::define::EV_ClientConnect*/
#define EV_ClientConnect(i,o) /*qc2rust::macro_begin::EV_ClientConnect*//** player */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_ClientConnect*/
MUTATOR_HOOKABLE(ClientConnect, EV_ClientConnect);

/*qc2rust::define::EV_HavocBot_ChooseRole*/
#define EV_HavocBot_ChooseRole(i,o) /*qc2rust::macro_begin::EV_HavocBot_ChooseRole*//** bot */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_HavocBot_ChooseRole*/
MUTATOR_HOOKABLE(HavocBot_ChooseRole, EV_HavocBot_ChooseRole);

/** called when a target is checked for accuracy */
/*qc2rust::define::EV_AccuracyTargetValid*/
#define EV_AccuracyTargetValid(i,o) /*qc2rust::macro_begin::EV_AccuracyTargetValid*//** attacker */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** target */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /**/ /*qc2rust::macro_end::EV_AccuracyTargetValid*/
MUTATOR_HOOKABLE(AccuracyTargetValid, EV_AccuracyTargetValid);
enum {
	MUT_ACCADD_VALID, // return this flag to make the function continue if target is a client
	MUT_ACCADD_INVALID, // return this flag to make the function always continue
	MUT_ACCADD_INDIFFERENT // return this flag to make the function always return
};

/** Called when clearing the global parameters for a model */
MUTATOR_HOOKABLE(ClearModelParams, EV_NO_ARGS);

/** Called when getting the global parameters for a model */
/*qc2rust::define::EV_GetModelParams*/
#define EV_GetModelParams(i,o) /*qc2rust::macro_begin::EV_GetModelParams*//** input */    /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_0_string)     /** command */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_1_string)     /**/ /*qc2rust::macro_end::EV_GetModelParams*/
MUTATOR_HOOKABLE(GetModelParams, EV_GetModelParams);

/** called when a bullet has hit a target */
/*qc2rust::define::EV_FireBullet_Hit*/
#define EV_FireBullet_Hit(i,o) /*qc2rust::macro_begin::EV_FireBullet_Hit*//** player */        /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** targ */          /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /** start pos */     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(vector, MUTATOR_ARGV_2_vector)     /** end pos */       /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(vector, MUTATOR_ARGV_3_vector)     /** damage */        /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_4_float)     /**/                 /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_4_float)     /** wep entity */    /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_5_entity)     /**/ /*qc2rust::macro_end::EV_FireBullet_Hit*/
MUTATOR_HOOKABLE(FireBullet_Hit, EV_FireBullet_Hit);

/*qc2rust::define::EV_FixPlayermodel*/
#define EV_FixPlayermodel(i,o) /*qc2rust::macro_begin::EV_FixPlayermodel*//** model */     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_0_string)     /**/             /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(string, MUTATOR_ARGV_0_string)     /** skin */      /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_1_int)     /**/             /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(int, MUTATOR_ARGV_1_int)     /** player */    /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_2_entity)     /**/ /*qc2rust::macro_end::EV_FixPlayermodel*/
MUTATOR_HOOKABLE(FixPlayermodel, EV_FixPlayermodel);

/** Return error to play frag remaining announcements */
MUTATOR_HOOKABLE(Scores_CountFragsRemaining, EV_NO_ARGS);

/*qc2rust::define::EV_GrappleHookThink*/
#define EV_GrappleHookThink(i,o) /*qc2rust::macro_begin::EV_GrappleHookThink*//** hook */                 /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** tarzan */               /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_1_int)     /**/                        /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(int, MUTATOR_ARGV_1_int)     /** pulling entity */       /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_2_entity)     /**/                        /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(entity, MUTATOR_ARGV_2_entity)     /** velocity multiplier */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_3_float)     /**/                        /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_3_float)     /**/ /*qc2rust::macro_end::EV_GrappleHookThink*/
MUTATOR_HOOKABLE(GrappleHookThink, EV_GrappleHookThink);

/*qc2rust::define::EV_BuffModel_Customize*/
#define EV_BuffModel_Customize(i,o) /*qc2rust::macro_begin::EV_BuffModel_Customize*//** buff */     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** player */   /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /**/ /*qc2rust::macro_end::EV_BuffModel_Customize*/
MUTATOR_HOOKABLE(BuffModel_Customize, EV_BuffModel_Customize);

/** called at when a buff is touched. Called early, can edit buff properties. */
/*qc2rust::define::EV_BuffTouch*/
#define EV_BuffTouch(i,o) /*qc2rust::macro_begin::EV_BuffTouch*//** buff */     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** player */   /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /**/            /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(entity, MUTATOR_ARGV_1_entity)     /**/ /*qc2rust::macro_end::EV_BuffTouch*/
MUTATOR_HOOKABLE(BuffTouch, EV_BuffTouch);

MUTATOR_HOOKABLE(SetNewParms, EV_NO_ARGS);

MUTATOR_HOOKABLE(SetChangeParms, EV_NO_ARGS);

MUTATOR_HOOKABLE(DecodeLevelParms, EV_NO_ARGS);

/*qc2rust::define::EV_GetRecords*/
#define EV_GetRecords(i,o) /*qc2rust::macro_begin::EV_GetRecords*//** page */            /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_0_int)     /** record list */     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_1_string)     /**/                   /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(string, MUTATOR_ARGV_1_string)     /**/ /*qc2rust::macro_end::EV_GetRecords*/
MUTATOR_HOOKABLE(GetRecords, EV_GetRecords);

/*qc2rust::define::EV_Race_FinalCheckpoint*/
#define EV_Race_FinalCheckpoint(i,o) /*qc2rust::macro_begin::EV_Race_FinalCheckpoint*//** player */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_Race_FinalCheckpoint*/
MUTATOR_HOOKABLE(Race_FinalCheckpoint, EV_Race_FinalCheckpoint);

/** called when player triggered kill (or is changing teams), return error to not do anything */
/*qc2rust::define::EV_ClientKill*/
#define EV_ClientKill(i,o) /*qc2rust::macro_begin::EV_ClientKill*//** player */         /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** kill delay */     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_1_float)     /**/                  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_1_float)     /**/ /*qc2rust::macro_end::EV_ClientKill*/
MUTATOR_HOOKABLE(ClientKill, EV_ClientKill);

/** called when player is about to be killed during kill command or changing teams */
/*qc2rust::define::EV_ClientKill_Now*/
#define EV_ClientKill_Now(i,o) /*qc2rust::macro_begin::EV_ClientKill_Now*//** player */         /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_ClientKill_Now*/
MUTATOR_HOOKABLE(ClientKill_Now, EV_ClientKill_Now);

/*qc2rust::define::EV_FixClientCvars*/
#define EV_FixClientCvars(i,o) /*qc2rust::macro_begin::EV_FixClientCvars*//** player */         /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_FixClientCvars*/
MUTATOR_HOOKABLE(FixClientCvars, EV_FixClientCvars);

/*qc2rust::define::EV_SpectateSet*/
#define EV_SpectateSet(i,o) /*qc2rust::macro_begin::EV_SpectateSet*//** client */     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** target */     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /**/              /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(entity, MUTATOR_ARGV_1_entity)     /**/ /*qc2rust::macro_end::EV_SpectateSet*/
MUTATOR_HOOKABLE(SpectateSet, EV_SpectateSet);

/*qc2rust::define::EV_SpectateNext*/
#define EV_SpectateNext(i,o) /*qc2rust::macro_begin::EV_SpectateNext*//** client */     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** target */     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /**/              /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(entity, MUTATOR_ARGV_1_entity)     /**/ /*qc2rust::macro_end::EV_SpectateNext*/
MUTATOR_HOOKABLE(SpectateNext, EV_SpectateNext);

/*qc2rust::define::EV_SpectatePrev*/
#define EV_SpectatePrev(i,o) /*qc2rust::macro_begin::EV_SpectatePrev*//** client */     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** target */     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /**/              /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(entity, MUTATOR_ARGV_1_entity) 	/** first */      /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_2_entity)     /**/ /*qc2rust::macro_end::EV_SpectatePrev*/
MUTATOR_HOOKABLE(SpectatePrev, EV_SpectatePrev);

enum {
    MUT_SPECPREV_CONTINUE, // return this flag to make the function continue as normal
    MUT_SPECPREV_RETURN, // return this flag to make the function return (handled entirely by mutator)
    MUT_SPECPREV_FOUND // return this flag to make the function continue without default functions (handled mostly by mutator)
};

/** called when player triggered kill (or is changing teams), return error to not do anything */
/*qc2rust::define::EV_Bot_FixCount*/
#define EV_Bot_FixCount(i,o) /*qc2rust::macro_begin::EV_Bot_FixCount*//** active real players */   /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_0_int) 	/**/     					 /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(int, MUTATOR_ARGV_0_int)     /** real players */    		 /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_1_int)     /**/    					 /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(int, MUTATOR_ARGV_1_int)     /**/ /*qc2rust::macro_end::EV_Bot_FixCount*/
MUTATOR_HOOKABLE(Bot_FixCount, EV_Bot_FixCount);

/*qc2rust::define::EV_ClientCommand_Spectate*/
#define EV_ClientCommand_Spectate(i,o) /*qc2rust::macro_begin::EV_ClientCommand_Spectate*//** player */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_ClientCommand_Spectate*/
MUTATOR_HOOKABLE(ClientCommand_Spectate, EV_ClientCommand_Spectate);

enum {
    MUT_SPECCMD_CONTINUE, // return this flag to make the function continue as normal
    MUT_SPECCMD_RETURN, // return this flag to make the function return (don't spectate)
    MUT_SPECCMD_FORCE // return this flag to force the player to spectate, even if they're not a player
};

/*qc2rust::define::EV_CheckRules_World*/
#define EV_CheckRules_World(i,o) /*qc2rust::macro_begin::EV_CheckRules_World*//** status */     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_0_float)     /**/              /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_0_float)     /* time limit */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_1_float)     /* frag limit */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_2_float)     /**/ /*qc2rust::macro_end::EV_CheckRules_World*/
MUTATOR_HOOKABLE(CheckRules_World, EV_CheckRules_World);

/*qc2rust::define::EV_WantWeapon*/
#define EV_WantWeapon(i,o) /*qc2rust::macro_begin::EV_WantWeapon*//** weapon info entity */     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** do want? */               /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_1_float)     /**/                          /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_1_float)     /** want all guns */          /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(bool, MUTATOR_ARGV_2_bool)     /**/                          /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(bool, MUTATOR_ARGV_2_bool)     /** want mutator blocked */   /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(bool, MUTATOR_ARGV_3_bool)     /**/                          /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(bool, MUTATOR_ARGV_3_bool)     /**/ /*qc2rust::macro_end::EV_WantWeapon*/
MUTATOR_HOOKABLE(WantWeapon, EV_WantWeapon);

/*qc2rust::define::EV_AddPlayerScore*/
#define EV_AddPlayerScore(i,o) /*qc2rust::macro_begin::EV_AddPlayerScore*//** score field */   /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** score */         /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_1_float)     /**/                 /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_1_float)     /** player */        /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_2_entity)     /**/ /*qc2rust::macro_end::EV_AddPlayerScore*/
MUTATOR_HOOKABLE(AddPlayerScore, EV_AddPlayerScore);

/*qc2rust::define::EV_AddedPlayerScore*/
#define EV_AddedPlayerScore(i,o) /*qc2rust::macro_begin::EV_AddedPlayerScore*//** score field */   /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** score */         /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_1_float)     /** player */        /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_2_entity)     /**/ /*qc2rust::macro_end::EV_AddedPlayerScore*/
MUTATOR_HOOKABLE(AddedPlayerScore, EV_AddPlayerScore);

/*qc2rust::define::EV_GetPlayerStatus*/
#define EV_GetPlayerStatus(i,o) /*qc2rust::macro_begin::EV_GetPlayerStatus*//** player */     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_GetPlayerStatus*/
MUTATOR_HOOKABLE(GetPlayerStatus, EV_GetPlayerStatus);

/*qc2rust::define::EV_SetWeaponArena*/
#define EV_SetWeaponArena(i,o) /*qc2rust::macro_begin::EV_SetWeaponArena*//** arena */      /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_0_string)     /**/              /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(string, MUTATOR_ARGV_0_string)     /**/ /*qc2rust::macro_end::EV_SetWeaponArena*/
MUTATOR_HOOKABLE(SetWeaponArena, EV_SetWeaponArena);

/*qc2rust::define::EV_DropSpecialItems*/
#define EV_DropSpecialItems(i,o) /*qc2rust::macro_begin::EV_DropSpecialItems*//** target */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_DropSpecialItems*/
MUTATOR_HOOKABLE(DropSpecialItems, EV_DropSpecialItems);

/**
 * called when an admin tries to kill all monsters
 * return 1 to prevent spawning
 */
/*qc2rust::define::EV_AllowMobButcher*/
#define EV_AllowMobButcher(i,o) /*qc2rust::macro_begin::EV_AllowMobButcher*//** reason */  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(string, MUTATOR_ARGV_0_string)     /**/ /*qc2rust::macro_end::EV_AllowMobButcher*/
MUTATOR_HOOKABLE(AllowMobButcher, EV_AllowMobButcher);

MUTATOR_HOOKABLE(ReadLevelCvars, EV_NO_ARGS);

/*qc2rust::define::EV_SendWaypoint*/
#define EV_SendWaypoint(i,o) /*qc2rust::macro_begin::EV_SendWaypoint*//** waypoint */      /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity) 	/** to */     		 /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity) 	/** send flags */    /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_2_int) 	/**/   				 /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(int, MUTATOR_ARGV_2_int) 	/** wp flag */       /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_3_int) 	/**/   				 /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(int, MUTATOR_ARGV_3_int)     /**/ /*qc2rust::macro_end::EV_SendWaypoint*/
MUTATOR_HOOKABLE(SendWaypoint, EV_SendWaypoint);

/*qc2rust::define::EV_TurretValidateTarget*/
#define EV_TurretValidateTarget(i,o) /*qc2rust::macro_begin::EV_TurretValidateTarget*//** turret */           /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** target */           /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /** validate flags */   /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_2_int)     /** target score */     /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(float, MUTATOR_ARGV_3_float)     /**/ /*qc2rust::macro_end::EV_TurretValidateTarget*/
MUTATOR_HOOKABLE(TurretValidateTarget, EV_TurretValidateTarget);

/*qc2rust::define::EV_TurretThink*/
#define EV_TurretThink(i,o) /*qc2rust::macro_begin::EV_TurretThink*//** turret */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_TurretThink*/
MUTATOR_HOOKABLE(TurretThink, EV_TurretThink);

MUTATOR_HOOKABLE(Ent_Init, EV_NO_ARGS);

/** */
/*qc2rust::define::EV_PrepareExplosionByDamage*/
#define EV_PrepareExplosionByDamage(i,o) /*qc2rust::macro_begin::EV_PrepareExplosionByDamage*//** projectile */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** attacker */    /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /**/ /*qc2rust::macro_end::EV_PrepareExplosionByDamage*/
MUTATOR_HOOKABLE(PrepareExplosionByDamage, EV_PrepareExplosionByDamage);

/** called when a monster model is about to be set, allows custom paths etc. */
/*qc2rust::define::EV_MonsterModel*/
#define EV_MonsterModel(i,o) /*qc2rust::macro_begin::EV_MonsterModel*//** model */   /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_0_string) 	/** output */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_1_string) 	/**/ 		   /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(string, MUTATOR_ARGV_1_string)     /**/ /*qc2rust::macro_end::EV_MonsterModel*/
MUTATOR_HOOKABLE(MonsterModel, EV_MonsterModel);

/**
 * Called before player changes their team. Return true to block team change.
 */
/*qc2rust::define::EV_Player_ChangeTeam*/
#define EV_Player_ChangeTeam(i,o) /*qc2rust::macro_begin::EV_Player_ChangeTeam*//** player */              /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** current team index */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_1_float)     /** new team index */      /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_2_float)     /**/ /*qc2rust::macro_end::EV_Player_ChangeTeam*/
MUTATOR_HOOKABLE(Player_ChangeTeam, EV_Player_ChangeTeam);

/**
 * Called after player has changed their team.
 */
/*qc2rust::define::EV_Player_ChangedTeam*/
#define EV_Player_ChangedTeam(i,o) /*qc2rust::macro_begin::EV_Player_ChangedTeam*//** player */              /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** old team index */      /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_1_float)     /** current team index */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_2_float)     /**/ /*qc2rust::macro_end::EV_Player_ChangedTeam*/
MUTATOR_HOOKABLE(Player_ChangedTeam, EV_Player_ChangedTeam);

/**
 * Called when player is about to be killed when changing teams. Return true to block killing.
 */
/*qc2rust::define::EV_Player_ChangeTeamKill*/
#define EV_Player_ChangeTeamKill(i,o) /*qc2rust::macro_begin::EV_Player_ChangeTeamKill*//** player */     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_Player_ChangeTeamKill*/
MUTATOR_HOOKABLE(Player_ChangeTeamKill, EV_Player_ChangeTeamKill);

/**/
/*qc2rust::define::EV_URI_GetCallback*/
#define EV_URI_GetCallback(i,o) /*qc2rust::macro_begin::EV_URI_GetCallback*//** id */        /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_0_float) 	/** status */    /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_1_float) 	/** data */      /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_2_string)     /**/ /*qc2rust::macro_end::EV_URI_GetCallback*/
MUTATOR_HOOKABLE(URI_GetCallback, EV_URI_GetCallback);

/**
 * return true to prevent weapon use for a player
 */
/*qc2rust::define::EV_ForbidWeaponUse*/
#define EV_ForbidWeaponUse(i,o) /*qc2rust::macro_begin::EV_ForbidWeaponUse*//** player */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_ForbidWeaponUse*/
MUTATOR_HOOKABLE(ForbidWeaponUse, EV_ForbidWeaponUse);

/** called when creating a clone of the player (usually for corpses that stay after the player has re-spawned) */
/*qc2rust::define::EV_CopyBody*/
#define EV_CopyBody(i,o) /*qc2rust::macro_begin::EV_CopyBody*//** player */                /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** newly created clone */   /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /** keepvelocity? */         /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(bool, MUTATOR_ARGV_2_bool)     /**/ /*qc2rust::macro_end::EV_CopyBody*/
MUTATOR_HOOKABLE(CopyBody, EV_CopyBody);

/** called when sending a chat message, ret argument can be changed to prevent the message */
/*qc2rust::define::EV_ChatMessage*/
#define EV_ChatMessage(i,o) /*qc2rust::macro_begin::EV_ChatMessage*//** sender */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** ret */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_1_int)     /**/  /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(int, MUTATOR_ARGV_1_int)     /**/ /*qc2rust::macro_end::EV_ChatMessage*/
MUTATOR_HOOKABLE(ChatMessage, EV_ChatMessage);

/** return true to prevent sending a chat (private, team or regular) message from reaching a certain player */
/*qc2rust::define::EV_ChatMessageTo*/
#define EV_ChatMessageTo(i,o) /*qc2rust::macro_begin::EV_ChatMessageTo*//** destination player */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** sender */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /**/ /*qc2rust::macro_end::EV_ChatMessageTo*/
MUTATOR_HOOKABLE(ChatMessageTo, EV_ChatMessageTo);

/** return true to just restart the match, for modes that don't support readyrestart */
MUTATOR_HOOKABLE(ReadyRestart_Deny, EV_NO_ARGS);

/** called when a fusion reactor is validating its target */
/*qc2rust::define::EV_FusionReactor_ValidTarget*/
#define EV_FusionReactor_ValidTarget(i,o) /*qc2rust::macro_begin::EV_FusionReactor_ValidTarget*//** turret */     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** target */     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_1_entity)     /**/ /*qc2rust::macro_end::EV_FusionReactor_ValidTarget*/
MUTATOR_HOOKABLE(FusionReactor_ValidTarget, EV_FusionReactor_ValidTarget);

enum {
    MUT_FUSREAC_TARG_CONTINUE, // return this flag to make the function continue as normal
    MUT_FUSREAC_TARG_VALID, // return this flag to make the function return true (valid target)
    MUT_FUSREAC_TARG_INVALID // return this flag to make the function return false (invalid target)
};

/** return true to hide the 'teamnumbers are imbalanced' message */
/*qc2rust::define::EV_HideTeamNagger*/
#define EV_HideTeamNagger(i,o) /*qc2rust::macro_begin::EV_HideTeamNagger*//** player */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_HideTeamNagger*/
MUTATOR_HOOKABLE(HideTeamNagger, EV_HideTeamNagger);

/** return true to show a waypoint while the item is spawning */
/*qc2rust::define::EV_Item_ScheduleRespawn*/
#define EV_Item_ScheduleRespawn(i,o) /*qc2rust::macro_begin::EV_Item_ScheduleRespawn*//** item */              /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** respawn time */      /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_1_float)     /**/ /*qc2rust::macro_end::EV_Item_ScheduleRespawn*/
MUTATOR_HOOKABLE(Item_ScheduleRespawn, EV_Item_ScheduleRespawn);

/** called before physics stats are set on a player, allows limited early customization */
/*qc2rust::define::EV_PlayerPhysics_UpdateStats*/
#define EV_PlayerPhysics_UpdateStats(i,o) /*qc2rust::macro_begin::EV_PlayerPhysics_UpdateStats*//** player */              /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_PlayerPhysics_UpdateStats*/
MUTATOR_HOOKABLE(PlayerPhysics_UpdateStats, EV_PlayerPhysics_UpdateStats);

/** called after physics stats are set on a player, allows post-initialization modifications */
/*qc2rust::define::EV_PlayerPhysics_PostUpdateStats*/
#define EV_PlayerPhysics_PostUpdateStats(i,o) /*qc2rust::macro_begin::EV_PlayerPhysics_PostUpdateStats*//** player */              /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** maxspeed_mod */        /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_1_float)     /**/ /*qc2rust::macro_end::EV_PlayerPhysics_PostUpdateStats*/
MUTATOR_HOOKABLE(PlayerPhysics_PostUpdateStats, EV_PlayerPhysics_PostUpdateStats);

/** return true to use your own aim target (or none at all) */
/*qc2rust::define::EV_HavocBot_Aim*/
#define EV_HavocBot_Aim(i,o) /*qc2rust::macro_begin::EV_HavocBot_Aim*//** bot */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_HavocBot_Aim*/
MUTATOR_HOOKABLE(HavocBot_Aim, EV_HavocBot_Aim);

/** return true to skip respawn time calculations */
/*qc2rust::define::EV_CalculateRespawnTime*/
#define EV_CalculateRespawnTime(i,o) /*qc2rust::macro_begin::EV_CalculateRespawnTime*//** player */  /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_CalculateRespawnTime*/
MUTATOR_HOOKABLE(CalculateRespawnTime, EV_CalculateRespawnTime);

/** called when parsing a vote command. */
/*qc2rust::define::EV_VoteCommand_Parse*/
#define EV_VoteCommand_Parse(i,o) /*qc2rust::macro_begin::EV_VoteCommand_Parse*//** caller */                            /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** first command */                     /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_1_string)     /** vote command */                      /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(string, MUTATOR_ARGV_2_string)     /** start position of vote command */    /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_3_float)     /** argument count */                    /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_4_float)     /**/ /*qc2rust::macro_end::EV_VoteCommand_Parse*/
MUTATOR_HOOKABLE(VoteCommand_Parse, EV_VoteCommand_Parse);

enum {
    MUT_VOTEPARSE_CONTINUE, // return this flag to make the function continue as normal
    MUT_VOTEPARSE_SUCCESS, // return 1 (vote parsed)
    MUT_VOTEPARSE_INVALID, // return -1 (vote parsed but counted as invalid, no action or vote)
    MUT_VOTEPARSE_UNACCEPTABLE // return 0 (vote parameter counted as unacceptable, warns caller)
};

/**
 * Called when freezing an entity (monster or player), return true to force showing a waypoint
 */
/*qc2rust::define::EV_Freeze*/
#define EV_Freeze(i,o) /*qc2rust::macro_begin::EV_Freeze*//** targ */              /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /** revive speed */      /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(float, MUTATOR_ARGV_1_float)     /** frozen type */       /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_2_int)     /**/ /*qc2rust::macro_end::EV_Freeze*/
MUTATOR_HOOKABLE(Freeze, EV_Freeze);

/**
 * Called when an entity (monster or player) is defrosted
 */
/*qc2rust::define::EV_Unfreeze*/
#define EV_Unfreeze(i,o) /*qc2rust::macro_begin::EV_Unfreeze*//** targ */              /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(entity, MUTATOR_ARGV_0_entity)     /**/ /*qc2rust::macro_end::EV_Unfreeze*/
MUTATOR_HOOKABLE(Unfreeze, EV_Unfreeze);

/**
 * Called when a player is trying to join, argument is the number of players allowed to join the match
 */
/*qc2rust::define::EV_GetPlayerLimit*/
#define EV_GetPlayerLimit(i,o) /*qc2rust::macro_begin::EV_GetPlayerLimit*//** g_maxplayers */              /*qc2rust::param_begin::i*/i /*qc2rust::param_end::i*/(int, MUTATOR_ARGV_0_int)     /**/                             /*qc2rust::param_begin::o*/o /*qc2rust::param_end::o*/(int, MUTATOR_ARGV_0_int)     /**/ /*qc2rust::macro_end::EV_GetPlayerLimit*/
MUTATOR_HOOKABLE(GetPlayerLimit, EV_GetPlayerLimit);
