#pragma once

entity round_handler;
.float delay; // stores delay from round end to countdown start
.float count; // stores initial number of the countdown
.bool wait; // it's set to true when round ends, to false when countdown starts
.float cnt;	// its initial value is .count + 1, then decreased while counting down
			// reaches 0 when the round starts
.float round_timelimit;
.float round_endtime;
.bool() canRoundStart;
.bool() canRoundEnd;
.void() roundStart;

void round_handler_Init(float the_delay, float the_count, float the_round_timelimit);
void round_handler_Spawn(bool() canRoundStart_func, bool() canRoundEnd_func, void() roundStart_func);
void round_handler_Reset(float next_think);
void round_handler_Remove();

/*qc2rust::define::round_handler_IsActive*/
#define round_handler_IsActive() /*qc2rust::macro_begin::round_handler_IsActive*/(round_handler != NULL) /*qc2rust::macro_end::round_handler_IsActive*/
/*qc2rust::define::round_handler_AwaitingNextRound*/
#define round_handler_AwaitingNextRound() /*qc2rust::macro_begin::round_handler_AwaitingNextRound*/(round_handler.wait) /*qc2rust::macro_end::round_handler_AwaitingNextRound*/
/*qc2rust::define::round_handler_CountdownRunning*/
#define round_handler_CountdownRunning() /*qc2rust::macro_begin::round_handler_CountdownRunning*/(!round_handler.wait && round_handler.cnt) /*qc2rust::macro_end::round_handler_CountdownRunning*/
/*qc2rust::define::round_handler_IsRoundStarted*/
#define round_handler_IsRoundStarted() /*qc2rust::macro_begin::round_handler_IsRoundStarted*/(!round_handler.wait && !round_handler.cnt) /*qc2rust::macro_end::round_handler_IsRoundStarted*/
/*qc2rust::define::round_handler_GetEndTime*/
#define round_handler_GetEndTime() /*qc2rust::macro_begin::round_handler_GetEndTime*/(round_handler.round_endtime) /*qc2rust::macro_end::round_handler_GetEndTime*/
